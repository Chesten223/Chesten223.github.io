<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2026 ä¸“å±ç¥ç¦</title>
    
    <link rel="icon" type="image/x-icon" href="../assets/favicon.ico">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode-generator/1.4.4/qrcode.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Microsoft YaHei', sans-serif;
            touch-action: none; 
        }

        #world {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background-image: radial-gradient(circle at 50% 50%, #030008 0%, #000000 90%);
            overflow: hidden;
        }

        canvas { display: block; }
        
        /* === å¯åŠ¨é¡µå®¹å™¨ === */
        #start-container {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
            transition: opacity 0.8s ease;
        }

        /* å¯åŠ¨æŒ‰é’® */
        #overlay {
            display: inline-block;
            color: rgba(255, 255, 255, 0.95);
            font-size: 16px;
            letter-spacing: 12px;
            cursor: pointer;
            background: rgba(20, 20, 30, 0.6); 
            backdrop-filter: blur(12px);
            padding: 20px 60px;
            border-radius: 100px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 30px rgba(100, 150, 255, 0.15);
            transition: transform 0.2s, box-shadow 0.3s;
            font-weight: 300;
            text-transform: uppercase;
            white-space: nowrap;
            position: relative;
            overflow: hidden;
        }

        #overlay:hover {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 50px rgba(120, 180, 255, 0.3);
            transform: scale(1.02);
        }
        
        #overlay:active { transform: scale(0.95); }

        /* æŒ‰é’®å…‰æ•ˆ */
        #overlay::before {
            content: ''; position: absolute;
            top: var(--y, 50%); left: var(--x, 50%);
            transform: translate(-50%, -50%);
            width: 150px; height: 150px;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
            opacity: 0; transition: opacity 0.3s;
            pointer-events: none; mix-blend-mode: overlay; 
        }
        #overlay:hover::before { opacity: 1; }

        /* === å¯åŠ¨é¡µä¸‹æ–¹ç‰ˆæƒå°å­— === */
        #start-subtext {
            margin-top: 15px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.4);
            letter-spacing: 1px;
            cursor: pointer;
            text-decoration: none;
            transition: color 0.3s;
        }
        #start-subtext:hover { color: rgba(255, 255, 255, 0.8); text-decoration: underline; }

        /* === å³ä¸Šè§’æ°´å° (ä»…å…è´¹ç‰ˆæ˜¾ç¤º) === */
        #watermark {
            position: absolute;
            top: 20px; right: 25px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.3);
            letter-spacing: 2px;
            z-index: 5;
            cursor: pointer;
            font-weight: bold;
            pointer-events: auto; /* ç¡®ä¿èƒ½ç‚¹å‡» */
            transition: all 0.3s;
            display: none; /* JSæ§åˆ¶æ˜¾ç¤º */
        }
        #watermark:hover {
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* === ç»“æŸåçš„å½©è›‹å¹¿å‘Š (ä»…å…è´¹ç‰ˆæ˜¾ç¤º) === */
        #end-ad {
            position: absolute;
            bottom: 40px; right: 30px; 
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            padding: 10px 20px;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px;
            letter-spacing: 1px;
            cursor: pointer;
            z-index: 8;
            opacity: 0; /* åˆå§‹éšè— */
            transform: translateY(20px);
            transition: all 0.8s cubic-bezier(0.22, 1, 0.36, 1);
            display: none; /* JSæ§åˆ¶æ˜¯å¦å­˜åœ¨ */
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        #end-ad:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(20px) scale(1.05);
            box-shadow: 0 5px 25px rgba(100, 200, 255, 0.3);
        }
        
        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 768px) {
            #end-ad {
                bottom: 30px;
                right: 50%;
                transform: translateX(50%) translateY(20px);
                width: max-content;
            }
            #end-ad:hover {
                transform: translateX(50%) translateY(20px) scale(1.05);
            }
            #end-ad.visible {
                opacity: 1;
                transform: translateX(50%) translateY(0) !important;
            }
        }
        
        @media (min-width: 769px) {
            #end-ad.visible {
                opacity: 1;
                transform: translateY(0) !important;
            }
        }

    </style>
</head>
<body>

<div id="world">
    <div id="start-container">
        <div id="overlay" onmousemove="moveGlow(event)" ontouchmove="moveGlow(event)">å¼€å¯ 2026</div>
        <div id="start-subtext" onclick="goBuy()">Powered by ä¸ƒå¶æ€€ç‘¾ | å®šåˆ¶ä¸“å±æ–‡å­—</div>
    </div>

    <div id="watermark" onclick="goBuy()">ä¸ƒå¶æ€€ç‘¾</div>

    <div id="end-ad" onclick="goBuy()">
        æˆ‘ä¹Ÿè¦é€ TA ä¸€ç‰‡ç‹¬ç‰¹ç¥ç¦çš„æ˜Ÿç©º <span style="margin-left:8px; opacity:0.7">ğŸ‘‰ ç‚¹å‡»è·å–ä¸“å±é“¾æ¥</span>
    </div>

    <canvas id="canvas"></canvas>
</div>

<script>
    // === V34.0 åç«¯è§£å¯†ç‰ˆ (é€‚é… Python Server) ===
    
    // é…ç½®è·³è½¬é“¾æ¥
    const BUY_LINK = "../#buy"; 
    // åç«¯è§£å¯†æ¥å£åœ°å€ (è¯·ç¡®ä¿ä¸ä½ çš„ server.py ç«¯å£ä¸€è‡´)
    const API_DECODE_URL = "https://vimalin.xyz:8443/api/decode"; 

    let config = {
        // === é»˜è®¤å…è´¹ç‰ˆå†…å®¹ ===
        textList: [
            "3", "2", "1", 
            "2026", 
            "æ˜Ÿæ²³é•¿æ˜", 
            "ä¸‡äº‹èƒœæ„", 
            "æ‰€æ„¿çš†å¾—"
        ],
        textDuration: [1500, 1500, 1500, 3000, 3000, 3000, 4000],
        
        totalParticles: 9000, 
        nebulaRatio: 0.4,     
        nebulaRadiusBase: 300, 
        ringInnerBase: 380,    
        ringOuterMult: 1.6,    
        poseX: 0.4,    
        poseZ: -0.15,  
        perspective: 1000,
        introDuration: 4000,   
        startScale: 5.0,       
        startTwist: 2.0,       
        loopRotationSpeed: -0.001, 
        trailAlpha: 0.12 
    };

    // å…¨å±€çŠ¶æ€
    let isPaidUser = false; // æ˜¯å¦ä»˜è´¹ç‰ˆ
    let hasShownAd = false; // æ˜¯å¦å·²å±•ç¤ºè¿‡ç»“å°¾å¹¿å‘Š

    function goBuy() {
        window.location.href = BUY_LINK;
    }

    function moveGlow(e) {
        const btn = e.currentTarget;
        const rect = btn.getBoundingClientRect();
        let clientX = e.clientX;
        let clientY = e.clientY;
        if(e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        }
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        btn.style.setProperty('--x', x + 'px');
        btn.style.setProperty('--y', y + 'px');
    }

    // === ã€æ ¸å¿ƒä¿®æ”¹ã€‘é€šè¿‡ API è·å–è§£å¯†æ•°æ® ===
    async function fetchDecryptedPayload() {
        const params = new URLSearchParams(window.location.search);
        const code = params.get('code');
        
        if (code) {
            try {
                // å‘åç«¯å‘èµ·è¯·æ±‚ï¼Œè®©åç«¯è§£å¯†
                const response = await fetch(API_DECODE_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code: code })
                });
                
                const result = await response.json();
                
                if (result.success && result.data) {
                    const payload = result.data;
                    console.log("Verified Gift:", payload);
                    
                    // === åªæœ‰åç«¯è§£å¯†æˆåŠŸï¼Œæ‰æ˜¾ç¤ºå®šåˆ¶å†…å®¹ === 
                    if (payload.wish) { 
                        isPaidUser = true; // æ ‡è®°ä¸ºä»˜è´¹ç”¨æˆ· 
                        
                        // 1. æ„å»ºåŸºç¡€æ’­æ”¾åˆ—è¡¨ (å€’è®¡æ—¶) 
                        let newTextList = ["3", "2", "1"]; 
                        
                        // 3. æ’å…¥ 2026 (å›ºå®šå¹´ä»½) 
                        // newTextList.push("2026"); 
                        
                        // 4. ã€æ ¸å¿ƒä¿®æ”¹ã€‘å¤„ç†å¤šè¡Œç¥ç¦è¯­ 
                        if(payload.wish) { 
                            // æŒ‰å›è½¦ç¬¦ (\n) åˆ†å‰²ï¼Œå¹¶è¿‡æ»¤æ‰ç©ºè¡Œ 
                            const lines = payload.wish.split('\n').filter(line => line.trim() !== ''); 
                            // æŠŠåˆ†å‰²åçš„æ¯ä¸€å¥éƒ½åŠ åˆ°æ’­æ”¾åˆ—è¡¨é‡Œ 
                            newTextList.push(...lines); 
                        } 
                        
                        config.textList = newTextList; 
                        
                        // 5. é‡æ–°è®¡ç®—æ¯å¥è¯çš„æ’­æ”¾æ—¶é•¿ 
                        config.textDuration = newTextList.map(text => { 
                            // å¦‚æœæ˜¯çº¯æ•°å­—ä¸”å¾ˆçŸ­(å€’è®¡æ—¶)ï¼Œæ’­æ”¾ 1.5ç§’ 
                            if (/^\d+$/.test(text) && text.length < 3) return 1500; 
                            // å…¶ä»–æ–‡å­—æ’­æ”¾ 3.5ç§’ 
                            return 3500; 
                        }); 

                        // åˆ·æ–° UI çŠ¶æ€ 
                        initUI(); 
                    }
                }
            } catch (e) {
                console.error("API Error:", e);
                // å¦‚æœå‡ºé”™ï¼ˆæ¯”å¦‚æ–­ç½‘ï¼‰ï¼Œç»´æŒå…è´¹ç‰ˆé…ç½®
            }
        }
    }
    
    // ç«‹å³æ‰§è¡Œè·å–
    fetchDecryptedPayload();

    // === UI åˆå§‹åŒ–é€»è¾‘ ===
    function initUI() {
        if (isPaidUser) {
            // ä»˜è´¹ç‰ˆï¼šç§»é™¤æ°´å°ï¼Œç§»é™¤ç»“å°¾å¹¿å‘Šï¼Œç§»é™¤å¯åŠ¨é¡µçš„â€œPowered Byâ€
            const wm = document.getElementById('watermark');
            if(wm) wm.style.display = 'none';
            
            // const endAd = document.getElementById('end-ad');
            // if(endAd) endAd.style.display = 'none';

            // const subtext = document.getElementById('start-subtext');
            // if(subtext) subtext.style.display = 'none'; // ç”šè‡³å¯ä»¥è¿å¯åŠ¨é¡µä¸‹æ–¹çš„ç‰ˆæƒä¹Ÿéšè—ï¼Œçœ‹ä½ éœ€æ±‚
            const endAd = document.getElementById('end-ad');
            if(endAd) endAd.style.display = 'block';
            console.log("UI Cleaned for VIP");
        } else {
            // å…è´¹ç‰ˆï¼šæ˜¾ç¤ºæ°´å°ï¼Œå‡†å¤‡ç»“å°¾å¹¿å‘Š
            const wm = document.getElementById('watermark');
            if(wm) wm.style.display = 'block';
            
            const endAd = document.getElementById('end-ad');
            if(endAd) endAd.style.display = 'block';
        }
    }
    // é¡µé¢åŠ è½½æ—¶å…ˆæ‰§è¡Œä¸€æ¬¡ï¼ˆé»˜è®¤å…è´¹çŠ¶æ€ï¼‰
    initUI();

    const world = document.getElementById('world');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let isMobile = false;
    
    const COS_POSE_X = Math.cos(config.poseX);
    const SIN_POSE_X = Math.sin(config.poseX);
    const COS_POSE_Z = Math.cos(config.poseZ);
    const SIN_POSE_Z = Math.sin(config.poseZ);

    let currentTextIndex = 0;
    const MAX_TEXT_PARTICLES = 25000; 
    let textParticlePool = []; 
    let currentEffect = 'converge'; 

    let galaxyParticles = []; 
    let isRunning = false;
    let startTime = 0; 

    function easeOutCubic(x) { return 1 - Math.pow(1 - x, 3); }

    function init() {
        const screenW = window.innerWidth;
        const screenH = window.innerHeight;

        // å¼ºåˆ¶æ¨ªå±é€»è¾‘
        if (screenW < screenH) {
            isMobile = true;
            world.style.width = screenH + 'px';
            world.style.height = screenW + 'px';
            world.style.transform = 'rotate(90deg)';
            world.style.transformOrigin = 'top left';
            world.style.left = '100%'; 
            world.style.top = '0';
            width = screenH;
            height = screenW;
        } else {
            isMobile = screenW < 1024;
            world.style.width = '100vw';
            world.style.height = '100vh';
            world.style.transform = 'none';
            world.style.left = '0';
            width = screenW;
            height = screenH;
        }

        // é«˜æ¸…å±é€‚é…
        const dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        ctx.scale(dpr, dpr);

        const minDim = Math.min(width, height);
        config.nebulaRadiusBase = minDim * 0.35; 
        config.ringInnerBase = minDim * 0.45;
        
        config.totalParticles = isMobile ? 6000 : 9000;

        createGalaxy();
        
        if (textParticlePool.length === 0) {
            for (let i = 0; i < MAX_TEXT_PARTICLES; i++) {
                textParticlePool.push(new TextParticle());
            }
        }
    }

    window.addEventListener('resize', () => {
        if(!isRunning) init();
    });

    class GalaxyParticle {
        constructor(type) { this.type = type; this.reset(); }
        reset() {
            const angle = Math.random() * Math.PI * 2;
            if (this.type === 'nebula') {
                const r = config.nebulaRadiusBase * Math.cbrt(Math.random()); 
                const phi = Math.acos((Math.random() * 2) - 1);
                this.targetX = r * Math.sin(phi) * Math.cos(angle);
                this.targetY = r * Math.sin(phi) * Math.sin(angle);
                this.targetZ = r * Math.cos(phi);
                const distRatio = r / config.nebulaRadiusBase;
                const hue = 280 - distRatio * 30; 
                this.colorBase = `hsla(${hue}, 85%, 65%,`; 
                const rimIntensity = Math.pow(distRatio, 4); 
                this.maxAlpha = 0.1 + 0.8 * rimIntensity;
                const sizeFactor = isMobile ? 0.5 : 0.8;
                if (distRatio > 0.85) this.size = (Math.random() * 2.0 + 1.0) * sizeFactor; 
                else this.size = (Math.random() * 1.2 + 0.3) * sizeFactor; 
            } else {
                const minR = config.ringInnerBase;
                const maxR = Math.max(width, height) * config.ringOuterMult; 
                const r = minR + (maxR - minR) * Math.pow(Math.random(), 1.5);
                this.targetX = r * Math.cos(angle);
                this.targetY = (Math.random() - 0.5) * (r * 0.05); 
                this.targetZ = r * Math.sin(angle);
                const rand = Math.random();
                const sizeFactor = isMobile ? 0.5 : 0.8;
                if (rand > 0.75) { 
                    this.colorBase = `hsla(42, 100%, 75%,`; 
                    this.size = (Math.random() * 2.0 + 0.8) * sizeFactor;
                    this.maxAlpha = 1.0;
                } else if (rand > 0.4) {
                    this.colorBase = `hsla(210, 70%, 70%,`; 
                    this.size = (Math.random() * 1.5 + 0.5) * sizeFactor;
                    this.maxAlpha = 0.7;
                } else {
                    this.colorBase = `hsla(265, 40%, 50%,`; 
                    this.size = (Math.random() * 1.2 + 0.4) * sizeFactor;
                    this.maxAlpha = 0.5;
                }
            }
            const rForSpeed = Math.sqrt(this.targetX**2 + this.targetZ**2);
            this.speedOffset = 200 / (rForSpeed + 50); 
            this.randomPhase = Math.random() * Math.PI * 2;
        }
        project(x, y, z) {
            let y2 = y * COS_POSE_X - z * SIN_POSE_X;
            let z2 = z * COS_POSE_X + y * SIN_POSE_X;
            let x2 = x;
            let x3 = x2 * COS_POSE_Z - y2 * SIN_POSE_Z;
            let y3 = y2 * COS_POSE_Z + x2 * SIN_POSE_Z;
            let z3 = z2;
            const scale = config.perspective / (config.perspective + z3);
            return { x: x3 * scale, y: y3 * scale, scale: scale };
        }
        updateIntro(progress, ctx, centerX, centerY) {
            const eased = easeOutCubic(progress);
            const scale = config.startScale - (config.startScale - 1) * eased;
            const twistAngle = (1 - eased) * config.startTwist * Math.PI * 2;
            const cosT = Math.cos(twistAngle);
            const sinT = Math.sin(twistAngle);
            const xRot = this.targetX * cosT - this.targetZ * sinT;
            const zRot = this.targetZ * cosT + this.targetX * sinT;
            const curX = xRot * scale;
            const curY = this.targetY * scale;
            const curZ = zRot * scale;
            const p = this.project(curX, curY, curZ);
            if (p.scale <= 0) return;
            const screenX = centerX + p.x;
            const screenY = centerY + p.y;
            if (screenX < -20 || screenX > width + 20 || screenY < -20 || screenY > height + 20) return;
            let fadeProgress = Math.pow(Math.max(0, (progress - 0.1) / 0.9), 2); 
            let alpha = this.maxAlpha * fadeProgress;
            if (alpha > 0.01) {
                ctx.fillStyle = this.colorBase + alpha + ')';
                ctx.beginPath();
                const blur = 1 + (1 - eased) * 2;
                ctx.arc(screenX, screenY, this.size * p.scale * blur, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        updateLoop(time, ctx, centerX, centerY) {
            const rotAngle = time * config.loopRotationSpeed * this.speedOffset;
            const cosRot = Math.cos(rotAngle);
            const sinRot = Math.sin(rotAngle);
            let x1 = this.targetX * cosRot - this.targetZ * sinRot;
            let z1 = this.targetZ * cosRot + this.targetX * sinRot;
            let y1 = this.targetY;
            const p = this.project(x1, y1, z1);
            if (p.scale <= 0) return;
            const screenX = centerX + p.x;
            const screenY = centerY + p.y;
            if (screenX < -20 || screenX > width + 20 || screenY < -20 || screenY > height + 50) return;
            const breath = 0.7 + 0.3 * Math.sin(time * 0.03 + this.randomPhase);
            let alpha = this.maxAlpha;
            let depthAlpha = (z1 + 2000) / 4000;
            if (this.type === 'nebula') {
                alpha *= (breath * 0.8 + 0.4); 
                depthAlpha = depthAlpha * 0.8 + 0.3; 
            } else {
                alpha *= (0.85 + 0.15 * Math.sin(time * 0.1 + this.randomPhase));
            }
            let finalAlpha = alpha * depthAlpha;
            if (finalAlpha > 0.01) {
                ctx.fillStyle = this.colorBase + finalAlpha + ')';
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.size * p.scale, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    class TextParticle {
        constructor() {
            this.active = false;
            this.x = 0; this.y = 0;
            this.targetX = 0; this.targetY = 0;
            this.vx = 0; this.vy = 0;
            this.angle = 0; this.radius = 0;
            this.color = '';
            this.size = 2.0;
        }
        activate(targetX, targetY, effectType, size = 2.0) {
            this.active = true;
            this.targetX = targetX;
            this.targetY = targetY;
            const mobileScale = isMobile ? 0.6 : 1.0; 
            this.color = `rgba(220, 240, 255, ${0.7 + Math.random() * 0.3})`;
            this.size = 2.0 * mobileScale;
            
            if (this.x === 0 && this.y === 0) {
                 this.x = Math.random() * width;
                 this.y = Math.random() * height;
            }
            switch (effectType) {
                case 'explode': 
                    const dx = this.x - width/2;
                    const dy = this.y - height/2;
                    this.vx = dx * 0.05 + (Math.random() - 0.5) * 10;
                    this.vy = dy * 0.05 + (Math.random() - 0.5) * 10;
                    break;
                case 'spiral': 
                    this.angle = Math.random() * Math.PI * 2;
                    this.radius = 300 + Math.random() * 200; 
                    this.x = targetX + Math.cos(this.angle) * this.radius;
                    this.y = targetY + Math.sin(this.angle) * this.radius;
                    break;
                case 'converge': default: break;
            }
        }
        update(effectType) {
            if (!this.active) return;
            switch (effectType) {
                case 'explode':
                    this.x += this.vx; this.y += this.vy;
                    this.vx *= 0.9; this.vy *= 0.9;
                    this.x += (this.targetX - this.x) * 0.08;
                    this.y += (this.targetY - this.y) * 0.08;
                    break;
                case 'spiral':
                    this.x += (this.targetX - this.x) * 0.08;
                    this.y += (this.targetY - this.y) * 0.08;
                    break;
                case 'converge': default:
                    this.x += (this.targetX - this.x) * 0.08;
                    this.y += (this.targetY - this.y) * 0.08;
                    break;
            }
        }
        draw(ctx) {
            if (!this.active) return;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function createGalaxy() {
        galaxyParticles = [];
        const nebulaCount = Math.floor(config.totalParticles * config.nebulaRatio);
        const ringCount = config.totalParticles - nebulaCount;
        for (let i = 0; i < nebulaCount; i++) galaxyParticles.push(new GalaxyParticle('nebula'));
        for (let i = 0; i < ringCount; i++) galaxyParticles.push(new GalaxyParticle('ring'));
    }

    function getTextCoordinates(text) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = width;
        tempCanvas.height = height;
        
        let fontSize = Math.min(width, height) * 0.18; 
        if (isMobile) fontSize *= 1.4; 

        if (text.length > 8) fontSize *= 0.5;
        else if (text.length > 4) fontSize *= 0.6;
        if (isMobile && text.length > 5) fontSize *= 0.8;

        tempCtx.font = `bold ${fontSize}px "Microsoft YaHei", sans-serif`;
        tempCtx.fillStyle = 'white';
        tempCtx.textAlign = 'center';
        tempCtx.textBaseline = 'middle';
        tempCtx.fillText(text, width / 2, height / 2);
        
        const imageData = tempCtx.getImageData(0, 0, width, height);
        const data = imageData.data;
        const coords = [];
        
        const gap = isMobile ? 3 : 4; 
        
        for (let y = 0; y < height; y += gap) {
            for (let x = 0; x < width; x += gap) {
                if (data[(y * width + x) * 4 + 3] > 180) {
                    if (isMobile && Math.random() > 1.0) continue;
                    coords.push({ x: x, y: y });
                }
            }
        }
        return coords;
    }

    function switchText(index) {
        if (index >= config.textList.length) {
            currentTextIndex = 3; 
            index = 3;
            
            // å…è´¹ç‰ˆï¼šå¹¿å‘Šæ˜¾ç¤ºé€»è¾‘
            if (!hasShownAd) {
                const ad = document.getElementById('end-ad');
                if(ad) {
                    ad.style.display = 'block'; 
                    setTimeout(() => ad.classList.add('visible'), 100); 
                }
                hasShownAd = true;
            }
        }
        
        const text = config.textList[index];
        const coords = getTextCoordinates(text);
        
        const effects = ['converge', 'spiral', 'explode'];
        
        if (index < 3 && /^\d+$/.test(text)) {
             currentEffect = Math.random() > 0.5 ? 'explode' : 'converge';
        } else {
            currentEffect = effects[Math.floor(Math.random() * effects.length)];
        }

        textParticlePool.forEach(p => p.active = false);
        for (let i = 0; i < coords.length && i < textParticlePool.length; i++) {
            textParticlePool[i].activate(coords[i].x, coords[i].y, currentEffect);
        }

        setTimeout(() => {
            currentTextIndex++;
            switchText(currentTextIndex);
        }, config.textDuration[index] || 2500);
    }

    function animate(timestamp) {
        if (!startTime) startTime = timestamp;
        const elapsed = timestamp - startTime;
        const centerX = width / 2;
        const centerY = height / 2;

        ctx.fillStyle = `rgba(0, 0, 5, ${config.trailAlpha})`; 
        ctx.fillRect(0, 0, width, height);
        
        ctx.globalCompositeOperation = 'lighter';

        if (elapsed < config.introDuration) {
            const progress = elapsed / config.introDuration;
            galaxyParticles.forEach(p => p.updateIntro(progress, ctx, centerX, centerY));
        } else {
            const loopTime = elapsed - config.introDuration;
            galaxyParticles.forEach(p => p.updateLoop(loopTime, ctx, centerX, centerY));
        }

        ctx.globalCompositeOperation = 'source-over';
        textParticlePool.forEach(p => {
            p.update(currentEffect);
            p.draw(ctx);
        });

        requestAnimationFrame(animate);
    }

    init();

    const startContainer = document.getElementById('start-container');
    const overlay = document.getElementById('overlay');
    
    // ç‚¹å‡»å¼€å§‹æŒ‰é’®é€»è¾‘
    overlay.addEventListener('click', () => {
        // æ·¡å‡ºæ•´ä¸ªå¯åŠ¨å®¹å™¨
        startContainer.style.opacity = '0';
        setTimeout(() => startContainer.style.display = 'none', 800);
        
        if (!isRunning) {
            isRunning = true;
            init(); 
            switchText(0); 
            requestAnimationFrame(animate);
        }
    });

</script>
</body>
</html>