<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>åªæœ‰æ¯”å¿ƒæ‰èƒ½çœ‹åˆ°çš„è¯</title>
    
    <link rel="icon" type="image/x-icon" href="../assets/favicon.ico">
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Microsoft YaHei', sans-serif;
            touch-action: none; 
            -webkit-user-select: none;
            user-select: none;
        }

        #world {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: #000;
            overflow: hidden;
            transform-origin: center center;
            transition: transform 0.5s ease;
        }

        /* === æ‰‹æœºå¼ºåˆ¶æ¨ªå±æ ·å¼ === */
        body.mobile-mode #world {
            width: 100vh;
            height: 100vw;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
        }

        #three-canvas { display: block; width: 100%; height: 100%; }
        
        /* è°ƒè¯•çª—å£ (PCç«¯ä¿ç•™ï¼Œæ‰‹æœºç«¯éšè—) */
        /* === ä¿®æ”¹ï¼šç›¸æœºçª—å£æ”¹ä¸º 4:3 æ ‡å‡†æ¯”ä¾‹ï¼Œå¹¶æ”¯æŒæŠ˜å  === */ 
        #video-container { 
            position: absolute; 
            bottom: 20px; left: 20px; 
            width: 240px; height: 180px; /* æ”¹ä¸º 4:3 æ¨ªå±æ¯”ä¾‹ */ 
            border: 2px solid rgba(255, 105, 180, 0.5); 
            border-radius: 8px; 
            overflow: hidden; 
            z-index: 10; 
            opacity: 0; 
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */ 
            pointer-events: none; /* è®©é¼ æ ‡èƒ½ç©¿é€å®¹å™¨ */ 
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); 
            background: #000; 
            display: none; 
        } 

        /* æŠ˜å çŠ¶æ€ */ 
        #video-container.collapsed { 
            width: 32px; height: 32px; 
            border-radius: 50%; 
            border-color: rgba(255, 255, 255, 0.3); 
        } 
        /* æŠ˜å æ—¶éšè—è§†é¢‘å†…å®¹ */ 
        #video-container.collapsed video, 
        #video-container.collapsed canvas { 
            opacity: 0; 
            pointer-events: none; 
        } 

        /* åˆ‡æ¢æŒ‰é’® (å¿…é¡»è®¾ç½® pointer-events: auto å› ä¸ºçˆ¶å®¹å™¨æ˜¯ none) */ 
        #video-toggle { 
            position: absolute; 
            top: 0; right: 0; 
            width: 30px; height: 30px; 
            background: rgba(0, 0, 0, 0.6); 
            color: #fff; 
            font-size: 18px; 
            line-height: 30px; 
            text-align: center; 
            cursor: pointer; 
            z-index: 20; 
            pointer-events: auto; /* å…³é”®ï¼šå…è®¸ç‚¹å‡» */ 
            border-bottom-left-radius: 8px; 
            transition: background 0.2s; 
            /* åå‘æŠµæ¶ˆçˆ¶å®¹å™¨çš„é•œåƒï¼Œç¡®ä¿æ–‡å­—ä¸å */ 
            transform: scaleX(-1); 
        } 
        #video-toggle:hover { 
            background: rgba(255, 50, 100, 0.8); 
        }
        
        #input_video, #debug_canvas { 
            position: absolute; top:0; left:0; width: 100%; height: 100%; 
            object-fit: cover; 
        }

        #ui-container {
            position: absolute;
            top: 65%; left: 0; 
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 5;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            transition: opacity 1s;
        }

        #ui-hint {
            color: rgba(255, 180, 200, 0.9);
            font-size: 16px; 
            letter-spacing: 2px;
            text-shadow: 0 0 15px rgba(255, 50, 150, 0.8);
            margin-bottom: 20px;
            font-weight: 600;
            text-transform: uppercase;
        }

        #progress-bar-bg {
            width: 200px; height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.3s;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        
        #progress-bar {
            width: 0%; height: 100%;
            background: linear-gradient(90deg, #ff0055, #ff99cc, #fff);
            box-shadow: 0 0 20px #ff0055;
            transition: width 0.1s linear;
        }

        #start-container {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            text-align: center;
            width: 100%; 
            transition: opacity 0.8s ease;
        }

        #overlay {
            display: inline-block;
            color: rgba(255, 240, 245, 1);
            font-size: 18px;
            letter-spacing: 4px;
            cursor: pointer;
            background: rgba(80, 20, 40, 0.6); 
            backdrop-filter: blur(12px);
            padding: 20px 50px; 
            border-radius: 100px;
            border: 1px solid rgba(255, 105, 180, 0.6);
            box-shadow: 0 0 40px rgba(255, 20, 147, 0.5);
            transition: transform 0.2s;
            font-weight: bold;
            text-transform: uppercase;
        }

        #overlay:active { transform: scale(0.95); }

        #start-subtext {
            margin-top: 20px;
            font-size: 11px;
            color: rgba(255, 182, 193, 0.5);
            letter-spacing: 1px;
            cursor: pointer;
        }

        #watermark {
            position: absolute;
            top: 20px; right: 20px;
            font-size: 10px; 
            color: rgba(255, 255, 255, 0.3);
            letter-spacing: 2px;
            z-index: 5;
            cursor: pointer;
            font-weight: bold;
            pointer-events: auto;
            transition: all 0.3s;
            display: none;
        }

        #end-ad {
            position: absolute;
            bottom: 30px; 
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            width: 80%; 
            max-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            padding: 10px 0;
            text-align: center;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            letter-spacing: 1px;
            cursor: pointer;
            z-index: 8;
            opacity: 0;
            transition: all 0.8s cubic-bezier(0.22, 1, 0.36, 1);
            display: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        #end-ad.visible { opacity: 1; transform: translateX(-50%) translateY(0); }
        
        #loading-text {
            display: none;
            margin-top: 15px; 
            color: rgba(255, 192, 203, 0.6);
            font-size: 12px; letter-spacing: 2px;
        }

        /* === æ‰‹æœºç«¯è§¦æ§æŒ‰é’® === */
        #mobile-controls {
            display: none; /* ä»…æ‰‹æœºç«¯æ˜¾ç¤º */
            position: absolute;
            bottom: 80px; /* ä½ç½®è°ƒé«˜ä¸€ç‚¹ */
            left: 0;
            width: 100%;
            height: 120px;
            z-index: 30;
            justify-content: center; /* å±…ä¸­å¯¹é½ï¼ŒåŠ¨æ€è°ƒæ•´é—´è· */
            align-items: center;
            pointer-events: none; 
            gap: 60px; /* åˆå§‹é—´è· */
        }
        
        .touch-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px solid rgba(255, 105, 180, 0.4);
            background: radial-gradient(circle, rgba(255,105,180,0.2) 0%, transparent 60%);
            pointer-events: auto;
            position: relative;
            transition: transform 0.1s;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 20px rgba(255, 105, 180, 0.2);
        }

        /* æŒ‰é’®å†…çš„ç®­å¤´æç¤º */
        .touch-btn::before {
            content: '';
            position: absolute;
            width: 0; height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            opacity: 0.8;
            /* ä¿æŒåŸæœ‰ç®­å¤´æ ·å¼ï¼Œè™½ç„¶é€»è¾‘å˜ä¸ºä¸Šä¸‹æ‹‰ï¼Œä½†ä¸ºäº†æœ€å°åŒ–æ”¹åŠ¨ä¿ç•™åŸæ ·æˆ–å¯è‡ªè¡Œä¿®æ”¹ä¸ºä¸Šä¸‹ç®­å¤´ */
        }
        
        /* å·¦æŒ‰é’® */
        #btn-left::before {
            border-right: 10px solid #fff;
            left: 20px;
        }
        /* å³æŒ‰é’® */
        #btn-right::before {
            border-left: 10px solid #fff;
            right: 20px;
        }
        
        .touch-btn::after {
            content: '';
            width: 40px; height: 40px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            box-shadow: 0 0 15px #ff3366;
            opacity: 0.3;
            transition: all 0.2s;
        }

        .touch-btn.active {
            border-color: #fff;
            background: rgba(255, 50, 100, 0.3);
            box-shadow: 0 0 30px rgba(255, 50, 100, 0.6);
        }
        
        .touch-btn.active::after {
            opacity: 1;
            transform: scale(1.2);
            box-shadow: 0 0 25px #ff0055;
            background: #fff;
        }

        /* æ‰‹æœºæ—‹è½¬åçš„UIå¾®è°ƒ */
        body.mobile-mode #ui-container {
            top: 45%; 
        }

    </style>
</head>
<body>

<div id="world">
    <div id="start-container">
        <div id="overlay" onclick="startExperience()">âœ¨ å¼€å¯ 2026 é­”æ³• âœ¨</div>
        <div id="loading-text">æ­£åœ¨å”¤é†’...</div>
        <div id="start-subtext" onclick="goBuy()">Powered by ä¸ƒå¶æ€€ç‘¾</div>
    </div>

    <div id="ui-container">
        <div id="ui-hint">è¯·ç«–å±å¹¶å°†æ‰‹ä¸¾é«˜</div>
        <div id="progress-bar-bg"><div id="progress-bar"></div></div>
    </div>

    <div id="mobile-controls">
        <div id="btn-left" class="touch-btn"></div>
        <div id="btn-right" class="touch-btn"></div>
    </div>

    <div id="video-container">
        <video id="input_video" playsinline webkit-playsinline></video>
        <canvas id="debug_canvas"></canvas>
        <div id="video-toggle" onclick="toggleVideo()">âˆ’</div>
    </div>

    <div id="watermark" onclick="goBuy()">ä¸ƒå¶æ€€ç‘¾</div>
    <div id="end-ad" onclick="goBuy()">
        é€ TA ä¸€å¥ä¸“å±æƒ…è¯ <span style="margin-left:5px; opacity:0.7">ğŸ‘‰ å®šåˆ¶è¡¨ç™½æ–‡å­—</span>
    </div>

    <canvas id="three-canvas"></canvas>
    <canvas id="textCanvas" width="512" height="256" style="display:none;"></canvas>
</div>

<script type="module">
    import * as THREE from 'three';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

    // === æ£€æµ‹æ˜¯å¦ä¸ºæ‰‹æœº ===
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (isMobile) {
        document.body.classList.add('mobile-mode');
        // ä¿®æ”¹æç¤ºè¯­
        document.getElementById('ui-hint').innerText = "æŒ‰ä½æŒ‰é’® ä¸Šä¸‹æ–¹å‘æ‹‰å¼€";
    }

    // === é…ç½®åŒºåŸŸ ===
    const CONFIG = {
        handCloudColor: 0xff66aa,  
        heartColorA: 0xff0033,      
        heartColorB: 0xff99cc,      

        // ã€ä¿®æ”¹1ã€‘å¤§å¹…å¢å¼ºæ‰‹æœºç«¯è¾‰å…‰ï¼Œè®©å®ƒå‘å…‰ï¼
        bloomStrength: isMobile ? 2.5 : 1.3,        
        bloomRadius: isMobile ? 0.6 : 0.4,          
        
        handParticleCount: isMobile ? 1200 : 1500,   
        handParticleSize: isMobile ? 4.5 : 2.0,  // ç²’å­æ›´å¤§ 

        connectThreshold: 4.0,    
        
        // ã€ä¿®æ”¹ã€‘ï¼š2.5ç§’è¿›åº¦æ¡ã€‚æ»¡é€Ÿå……èƒ½(speed=2)æ—¶ï¼Œ300/2 = 150å¸§ = 2.5ç§’ 
        gestureHoldTime: 150, 
        
        morphParticleCount: isMobile ? 15000 : 25000, 
        textPhrases: ["I LOVE U", "FOREVER"], 
        textDisplayTime: 4.0,       
        beatsToPerform: 3,          

        handAttractStrength: 0.5,  
        handSwirlSpeed: 0.6,        
        handSpreadCharging: isMobile ? 6.0 : 7.0,    
        
        // ã€ä¿®æ”¹3ã€‘æ‹‰è¿‘ç›¸æœºï¼Œè®©æ•´ä½“ç‰©ä½“æ˜¾å¾—æ›´å¤§
        cameraZ: isMobile ? 55 : 70 
    };

    const BUY_LINK = "../#buy"; 
    const API_DECODE_URL = "https://vimalin.xyz:8443/api/decode"; 
    let isPaidUser = false;

    let scene, camera, renderer, composer;
    let handL, handR; 
    let morphSystem; 
    let clock = new THREE.Clock();

    const STATE = { SEARCHING: 0, ALIGNING: 1, CHARGING: 2, ACTIVE: 3 };
    let currentState = STATE.SEARCHING;
    let chargeCounter = 0;
    let handsData = [];
    let gestureCenter = new THREE.Vector3(0, 0, 0); 
    let isRunning = false; 

    // === æ‰‹æœºç«¯è§¦æ§çŠ¶æ€ ===
    // === æ‰‹æœºç«¯è§¦æ§çŠ¶æ€ === 
    // ã€ä¿®æ”¹ã€‘ï¼šå°†åæ ‡è®°å½•æ”¹å› X è½´ 
    let touchState = { 
        leftPressed: false, 
        rightPressed: false, 
        leftX: 0, 
        rightX: 0, 
        startXL: 0, 
        startXR: 0, 
        dragFactor: 0 // 0 = æ²¡æ‹‰, 1 = æ‹‰æ»¡ 
    };

    // === å…¨å±€å‡½æ•° ===
    window.goBuy = function() { window.location.href = BUY_LINK; };

    window.startExperience = async function() {
        const overlay = document.getElementById('overlay');
        const loadingText = document.getElementById('loading-text');
        
        overlay.style.display = 'none';
        loadingText.style.display = 'block';

        initThreeJS();

        if (isMobile) {
            loadingText.innerText = "æ­£åœ¨åˆå§‹åŒ–é­”æ³•ç²’å­...";
            initMobileControls();
            document.getElementById('mobile-controls').style.display = 'flex';
            setTimeout(startGameLoop, 500);
        } else {
            try {
                loadingText.innerText = "æ­£åœ¨åŠ è½½ AI æ¨¡å‹...";
                await initMediaPipe();
                document.getElementById('video-container').style.display = 'block';
                document.getElementById('video-container').style.opacity = '0.6';
                startGameLoop();
            } catch (error) {
                console.error(error);
                loadingText.innerText = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥ HTTPS";
                return;
            }
        }
    };

    function startGameLoop() {
        const startContainer = document.getElementById('start-container');
        startContainer.style.opacity = '0';
        setTimeout(() => startContainer.style.display = 'none', 800);
        document.getElementById('ui-container').style.opacity = '1';
        
        if (!isPaidUser) {
            const ad = document.getElementById('end-ad');
            if(ad) {
                ad.style.display = 'block';
                setTimeout(() => ad.classList.add('visible'), 2000);
            }
        }
        isRunning = true;
        animate();
    }

    // === æ‰‹æœºç«¯äº¤äº’é€»è¾‘é‡å†™ï¼šæŒ‰ä½ -> ä¸Šä¸‹é•¿è¾¹å¾€å¤–æ‹‰ ===
    function initMobileControls() {
        const btnL = document.getElementById('btn-left');
        const btnR = document.getElementById('btn-right');

        // é€šç”¨è§¦æ‘¸å¤„ç†
        const handleTouch = (e, isLeft, isStart) => {
            // é˜»æ­¢é»˜è®¤è¡Œä¸ºé˜²æ­¢æ»šåŠ¨
            if(e.type !== 'mousedown') e.preventDefault(); 
            
            const touch = e.touches ? e.touches[0] : e;
            // ã€å…³é”®ä¿®æ”¹ã€‘ï¼šè·å– Yè½´ (çºµå‘) åæ ‡ 
            const clientY = touch.clientY;

            if (isStart) {
                if(isLeft) {
                    touchState.leftPressed = true;
                    touchState.startYL = clientY;
                    touchState.leftY = clientY;
                    btnL.classList.add('active');
                } else {
                    touchState.rightPressed = true;
                    touchState.startYR = clientY;
                    touchState.rightY = clientY;
                    btnR.classList.add('active');
                }
            } else {
                // Endï¼šæ¾æ‰‹å¤ä½ 
                if(isLeft) {
                    touchState.leftPressed = false;
                    btnL.classList.remove('active');
                    btnL.style.transform = `translateY(0px)`;
                } else {
                    touchState.rightPressed = false;
                    btnR.classList.remove('active');
                    btnR.style.transform = `translateY(0px)`;
                }
            }
            updateMobileState();
        };

        // ç›‘å¬ç§»åŠ¨äº‹ä»¶ (åœ¨windowä¸Šç›‘å¬ä»¥é˜²æ­¢æ‰‹æŒ‡ç§»å‡ºæŒ‰é’®èŒƒå›´)
        window.addEventListener('touchmove', (e) => {
            if (!isRunning || !isMobile) return;
            for (let i = 0; i < e.touches.length; i++) {
                const t = e.touches[i];
                
                // ã€å…³é”®ä¿®æ”¹ã€‘ï¼šä½¿ç”¨å±å¹•é«˜åº¦çš„ä¸€åŠæ¥åŒºåˆ†æ‰‹æŒ‡æ˜¯åœ¨æ§åˆ¶"å·¦æŒ‰é’®"è¿˜æ˜¯"å³æŒ‰é’®" 
                // å› ä¸ºæ‰‹æœºæ˜¯ç«–ç€æ‹¿çš„ï¼Œ"å·¦æŒ‰é’®"(è§†è§‰ä¸Š)å…¶å®åœ¨å±å¹•çš„ä¸ŠåŠéƒ¨åˆ†(ç‰©ç†ä¸Š) 
                // "å³æŒ‰é’®"(è§†è§‰ä¸Š)å…¶å®åœ¨å±å¹•çš„ä¸‹åŠéƒ¨åˆ†(ç‰©ç†ä¸Š) 
                const halfH = window.innerHeight / 2;
                
                // æ§åˆ¶å·¦æŒ‰é’®ï¼ˆä¹Ÿå°±æ˜¯å±å¹•ä¸ŠåŠéƒ¨åˆ†çš„é‚£ä¸ªï¼‰ï¼šåªèƒ½å¾€ä¸Šæ‹‰ï¼ˆYå€¼å˜å°ï¼‰ 
                // è¿™é‡Œçš„åˆ¤å®šèŒƒå›´è®¾ä¸º < halfH + 50 æ˜¯ä¸ºäº†é˜²æ­¢æ‰‹æŒ‡ç¨å¾®æ»‘è¿‡ç•Œå°±å¤±æ•ˆ 
                if (touchState.leftPressed && t.clientY < halfH + 100) {
                    touchState.leftY = t.clientY;
                    // å¾€ä¸Šæ‹‰æ˜¯è´Ÿæ•° (clientY å˜å°) 
                    const delta = Math.min(0, t.clientY - touchState.startYL);
                    btnL.style.transform = `translateY(${delta}px)`;
                }
                
                // æ§åˆ¶å³æŒ‰é’®ï¼ˆä¹Ÿå°±æ˜¯å±å¹•ä¸‹åŠéƒ¨åˆ†çš„é‚£ä¸ªï¼‰ï¼šåªèƒ½å¾€ä¸‹æ‹‰ï¼ˆYå€¼å˜å¤§ï¼‰ 
                if (touchState.rightPressed && t.clientY > halfH - 100) {
                    touchState.rightY = t.clientY;
                    // å¾€ä¸‹æ‹‰æ˜¯æ­£æ•° (clientY å˜å¤§) 
                    const delta = Math.max(0, t.clientY - touchState.startYR);
                    btnR.style.transform = `translateY(${delta}px)`;
                }
            }
            updateMobileState();
        }, {passive: false});

        // ç»‘å®šæŒ‰é’®å¼€å§‹/ç»“æŸäº‹ä»¶ 
        btnL.addEventListener('touchstart', (e) => handleTouch(e, true, true), {passive:false});
        btnL.addEventListener('touchend', (e) => handleTouch(e, true, false));
        btnR.addEventListener('touchstart', (e) => handleTouch(e, false, true), {passive:false});
        btnR.addEventListener('touchend', (e) => handleTouch(e, false, false));
        
        // é¼ æ ‡å…¼å®¹è°ƒè¯•ï¼ˆç”µè„‘æµ‹è¯•ç”¨ï¼‰ 
        btnL.addEventListener('mousedown', (e) => handleTouch(e, true, true));
        window.addEventListener('mouseup', (e) => {
            if(touchState.leftPressed) handleTouch(e, true, false);
            if(touchState.rightPressed) handleTouch(e, false, false);
        });
    }

    function updateMobileState() {
        if (currentState === STATE.ACTIVE) return;
        
        if (touchState.leftPressed && touchState.rightPressed) {
            // è®¡ç®—æ‹‰å¼€è·ç¦» - ã€ä¿®æ”¹ã€‘ï¼šä½¿ç”¨ Y è½´å·®å€¼
            // å·¦è¾¹å‘ä¸Šæ‹‰(Yå˜å°)æ˜¯è´Ÿæ•°ï¼Œå³è¾¹å‘ä¸‹æ‹‰(Yå˜å¤§)æ˜¯æ­£æ•°
            // deltaL = Start - Current (å‘ä¸Šæ‹‰ï¼ŒStart > Current, ç»“æœä¸ºæ­£è¡¨ç¤ºæ‹‰å¼€è·ç¦»)
            // deltaR = Current - Start (å‘ä¸‹æ‹‰ï¼ŒCurrent > Start, ç»“æœä¸ºæ­£è¡¨ç¤ºæ‹‰å¼€è·ç¦»)
            
            const deltaL = touchState.startYL - touchState.leftY; 
            const deltaR = touchState.rightY - touchState.startYR; 
            
            const totalDrag = Math.max(0, deltaL) + Math.max(0, deltaR);
            // å‡è®¾æ‹‰å¼€ 100px ç®—æ»¡
            const maxDrag = 150; 
            touchState.dragFactor = Math.min(1.0, totalDrag / maxDrag);
            
            currentState = STATE.CHARGING;
        } else {
            touchState.dragFactor = 0;
            currentState = (touchState.leftPressed || touchState.rightPressed) ? STATE.ALIGNING : STATE.SEARCHING;
            chargeCounter = Math.max(0, chargeCounter - 10); // æ¾æ‰‹æ‰å¾—å¿«
        }
    }

    // === ã€æ ¸å¿ƒä¿®æ”¹ã€‘è·å–è§£å¯†æ•°æ® (å¸¦åŠ è½½é”ä¸é˜²è¯¯è§¦) === 
    async function fetchDecryptedPayload() { 
        const params = new URLSearchParams(window.location.search); 
        const code = params.get('code'); 
        const overlayBtn = document.getElementById('overlay'); 
         
        // åªæœ‰å½“å­˜åœ¨ code æ—¶ï¼Œæ‰éœ€è¦é”å®šç­‰å¾… 
        if (code) { 
            // --- 1. é”å®šæŒ‰é’®ï¼Œæ˜¾ç¤ºåŠ è½½ä¸­ --- 
            overlayBtn.innerText = "ä¿¡å·æ¥æ”¶ä¸­..."; 
            overlayBtn.style.pointerEvents = "none"; // ç¦æ­¢ç‚¹å‡» 
            overlayBtn.style.cursor = "wait";        // é¼ æ ‡å˜æ¼æ–— 
            overlayBtn.style.opacity = "0.8";        // ç¨å¾®å˜æš— 
            
            try { 
                const response = await fetch(API_DECODE_URL, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ code: code }) 
                }); 
                 
                const result = await response.json(); 
                 
                if (result.success && result.data) { 
                    const payload = result.data; 
                    
                    // åªè¦æœ‰å†…å®¹ï¼Œå°±è§†ä¸ºå®šåˆ¶ç‰ˆ 
                    if (payload.wish || payload.to || payload.from) { 
                        isPaidUser = true; 
                         
                        // 1. å¤„ç†ç¥ç¦è¯­ 
                        if (payload.wish) { 
                            const lines = payload.wish.split('\n').filter(line => line.trim() !== ''); 
                            CONFIG.textPhrases = lines; 
                        } 

                        // 2. è·å–ç§°å‘¼ 
                        const toUser = payload.to ? payload.to.trim() : ""; 
                        const fromUser = payload.from ? payload.from.trim() : ""; 

                        // 3. --- æ ¹æ®æƒ…æ™¯å®šåˆ¶æŒ‰é’®æ–‡æ¡ˆ (æˆåŠŸè·å–åæ›´æ–°) --- 
                        if (toUser && fromUser) { 
                            // åŒäººï¼šå¼ºè°ƒ"ä¸“å±é¢‘æ®µ" 
                            overlayBtn.innerText = `âš¡ ${fromUser} å‘é€ç»™ ${toUser} çš„å¿ƒåŠ¨é¢‘æ®µ`; 
                            overlayBtn.style.letterSpacing = '1px'; 
                            overlayBtn.style.fontSize = '14px'; 
                            overlayBtn.style.padding = '20px 25px'; 
                        } else if (toUser) { 
                            // ä»…æ¥æ”¶è€…ï¼šå¼ºè°ƒ"æ¥æ”¶" 
                            overlayBtn.innerText = `ğŸ’Œ ${toUser}ï¼Œè¯·æ¥æ”¶è¿™ä»½ä¸“å±é¢‘ç‡`; 
                            overlayBtn.style.letterSpacing = '1px'; 
                            overlayBtn.style.fontSize = '15px'; 
                        } else if (fromUser) { 
                            // ä»…å‘é€è€…ï¼šå¼ºè°ƒ"è·¨è¶Šæ—¶ç©º" 
                            overlayBtn.innerText = `ğŸ“¡ æ¥è‡ª ${fromUser} çš„è·¨æ—¶ç©ºä¿¡å·`; 
                            overlayBtn.style.letterSpacing = '2px'; 
                            overlayBtn.style.fontSize = '15px'; 
                        } else { 
                            // æœ‰ç¥ç¦è¯­ä½†æ²¡åå­— 
                            overlayBtn.innerText = "ğŸ’– åŒæ‰‹æ¯”å¿ƒï¼Œè¿æ¥ä¸“å±é¢‘é“"; 
                            overlayBtn.style.letterSpacing = '4px'; 
                        } 
                    } 
                } else { 
                    // åç«¯è¿”å›æˆåŠŸä½†æ²¡æ•°æ®ï¼Œæ¢å¤é»˜è®¤ 
                    overlayBtn.innerText = "âœ¨ å¼€å¯ 2026 é­”æ³• âœ¨"; 
                } 
            } catch (e) { 
                console.error("API Error", e); 
                // ç½‘ç»œé”™è¯¯ï¼Œæ¢å¤é»˜è®¤ï¼Œä¿è¯èƒ½ç© 
                overlayBtn.innerText = "âœ¨ å¼€å¯ 2026 é­”æ³• âœ¨"; 
            } finally { 
                // --- 4. æ— è®ºæˆåŠŸå¤±è´¥ï¼Œæœ€åå¿…é¡»è§£é”æŒ‰é’® --- 
                overlayBtn.style.pointerEvents = "auto"; 
                overlayBtn.style.cursor = "pointer"; 
                overlayBtn.style.opacity = "1"; 
                
                // åˆ·æ–° UI (éšè—æ°´å°ç­‰) 
                initUI(); 
            } 
        } else { 
            // æ²¡æœ‰ code çš„æƒ…å†µï¼Œç›´æ¥åˆå§‹åŒ– 
            initUI(); 
        } 
    }
    
    // === è§†é¢‘çª—å£æŠ˜å /å±•å¼€åŠŸèƒ½ === 
    function toggleVideo() { 
        const container = document.getElementById('video-container'); 
        const toggleBtn = document.getElementById('video-toggle'); 
        
        if (container.classList.contains('collapsed')) { 
            // å±•å¼€ 
            container.classList.remove('collapsed'); 
            toggleBtn.innerText = 'âˆ’'; 
        } else { 
            // æŠ˜å  
            container.classList.add('collapsed'); 
            toggleBtn.innerText = '+'; 
        } 
    } 

    function initUI() {
        if (isPaidUser) {
            const wm = document.getElementById('watermark');
            if(wm) wm.style.display = 'none';
            const endAd = document.getElementById('end-ad');
            if(endAd) endAd.style.display = 'none'; 
        } else {
            const wm = document.getElementById('watermark');
            if(wm) wm.style.display = 'block';
        }
    }

    function initThreeJS() {
        const canvas = document.getElementById('three-canvas');
        renderer = new THREE.WebGLRenderer({ canvas, antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050008, 0.015);

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, CONFIG.cameraZ);

        const renderScene = new RenderPass(scene, camera);
        // Bloom å‚æ•°åœ¨ Config ä¸­æ ¹æ®æ‰‹æœºè°ƒæ•´äº†
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = CONFIG.bloomStrength;
        bloomPass.radius = CONFIG.bloomRadius;
        bloomPass.threshold = 0.05; // é˜ˆå€¼é™ä½ï¼Œæ›´å®¹æ˜“å‘å…‰

        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        handL = new SwirlHandCloud(CONFIG.handCloudColor);
        handR = new SwirlHandCloud(CONFIG.handCloudColor);
        morphSystem = new MorphingParticleSystem();

        window.addEventListener('resize', onResize);
        if(isMobile) onResize(); 
    }

    function onResize() {
        let w, h;
        if (isMobile) {
            w = window.innerHeight; 
            h = window.innerWidth;  
            renderer.setSize(w, h);
            composer.setSize(w, h);
            camera.aspect = w / h;
        } else {
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
        }
        camera.updateProjectionMatrix();
    }

    // === MediaPipe åˆå§‹åŒ– (ä»…PC) ===
    async function initMediaPipe() {
        const videoElement = document.getElementById('input_video');
        const debugCanvas = document.getElementById('debug_canvas');
        const debugCtx = debugCanvas.getContext('2d');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults((results) => {
            onHandResults(results);
            debugCtx.save();
            debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
            debugCtx.drawImage(results.image, 0, 0, debugCanvas.width, debugCanvas.height);
            
            // === ã€ä¿®æ”¹ã€‘æ³¨é‡Šæ‰ä¸‹é¢è¿™æ®µç»˜åˆ¶éª¨éª¼çš„ä»£ç  === 
            // if (results.multiHandLandmarks) {
            //     for (const landmarks of results.multiHandLandmarks) {
            //         drawConnectors(debugCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2}); 
            //         drawLandmarks(debugCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2}); 
            //     }
            // }
            // ========================================== 
            
            debugCtx.restore();
        });
        const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480, facingMode: 'user'});
        videoElement.onloadedmetadata = () => { debugCanvas.width = videoElement.videoWidth; debugCanvas.height = videoElement.videoHeight; };
        await cameraUtils.start();
    }

    function createSoftTexture() {
        const c = document.createElement('canvas'); c.width=64; c.height=64;
        const ctx = c.getContext('2d');
        const g = ctx.createRadialGradient(32,32,0,32,32,32);
        // è®©æ ¸å¿ƒæ›´äº®ï¼Œé…åˆBloom
        g.addColorStop(0, 'rgba(255,255,255,1)');
        g.addColorStop(0.2, 'rgba(255,200,220,0.8)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g; ctx.fillRect(0,0,64,64);
        return new THREE.CanvasTexture(c);
    }
    const commonTexture = createSoftTexture();

    class SwirlHandCloud {
        constructor(color) {
            this.count = CONFIG.handParticleCount;
            this.geo = new THREE.BufferGeometry();
            const pos = new Float32Array(this.count*3);
            const sizes = new Float32Array(this.count);
            const colors = new Float32Array(this.count*3);
            const c = new THREE.Color(color);

            for(let i=0; i<this.count; i++) {
                pos[i*3] = 0; pos[i*3+1] = 0; pos[i*3+2] = 0;
                sizes[i] = Math.random() * (CONFIG.handParticleSize * 0.8) + (CONFIG.handParticleSize * 0.2);
                colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
            }

            this.geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            this.geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            this.geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            this.mat = new THREE.PointsMaterial({
                vertexColors: true, size: 1.0, map: commonTexture,
                transparent: true, opacity: 0, blending: THREE.AdditiveBlending, depthWrite: false
            });

            this.mesh = new THREE.Points(this.geo, this.mat);
            scene.add(this.mesh);

            this.velocities = [];
            for(let i=0; i<this.count; i++) this.velocities.push({x:0, y:0, z:0});
        }

        update(targetPos, isDetected, isCharging, chargeCenter, progress, dragSpeedFactor = 0) {
            const positions = this.geo.attributes.position.array;
            
            // æ‰‹æœºç«¯å§‹ç»ˆæœ‰ç‚¹å¯è§åº¦
            let targetOpacity;
            if (isMobile) {
                targetOpacity = currentState === STATE.ACTIVE ? 0 : (isDetected ? 1.0 : 0.3);
            } else {
                targetOpacity = (isDetected && currentState !== STATE.ACTIVE) ? 0.8 : 0;
            }

            this.mat.opacity += (targetOpacity - this.mat.opacity) * 0.1;
            if (this.mat.opacity < 0.01) return;

            // æ‰‹æœºç«¯ï¼šæŒ‰ä¸‹åç²’å­å»ä¸­å¿ƒï¼Œå¦åˆ™åœ¨æŒ‰é’®å¤„
            // å¦‚æœ isCharging (Mobileæ¨¡å¼ä¸‹æŒ‡åŒæŒ‰äº†)ï¼Œåˆ™ç›®æ ‡ç‚¹å¼ºåˆ¶è®¾ä¸ºä¸­å¿ƒ
            const effectiveAttractPoint = (isMobile && isCharging) ? chargeCenter : targetPos;
            const spread = isCharging ? CONFIG.handSpreadCharging : (isMobile ? 8.0 : CONFIG.handSpreadNormal);
            const attractStrength = isCharging ? 0.3 : 0.1;

            for(let i=0; i<this.count; i++) {
                const idx = i*3;
                const v = this.velocities[i];
                const px = positions[idx]; const py = positions[idx+1]; const pz = positions[idx+2];

                // 1. å¼•åŠ›ï¼šé£å‘ç›®æ ‡
                v.x += (effectiveAttractPoint.x - px) * attractStrength * 0.1;
                v.y += (effectiveAttractPoint.y - py) * attractStrength * 0.1;
                v.z += (effectiveAttractPoint.z - pz) * attractStrength * 0.1;

                // 2. æ—‹è½¬ï¼šã€å…³é”®ä¿®æ”¹ã€‘é€Ÿåº¦æ ¹æ®æ‹‰å¼€è·ç¦»(dragSpeedFactor)å˜åŒ–
                if (isCharging) {
                    // åŸºç¡€é€Ÿåº¦ + æ‹‰å¼€å¸¦æ¥çš„ç‹‚æš´é€Ÿåº¦
                    let baseSpeed = isMobile ? 0.2 : CONFIG.handSwirlSpeed; 
                    let speedMult = isMobile ? (baseSpeed + dragSpeedFactor * 2.5) : (CONFIG.handSwirlSpeed + progress * 0.5);
                    
                    const rx = px - chargeCenter.x;
                    const ry = py - chargeCenter.y;
                    
                    // ç²’å­ç»•åœˆé€»è¾‘
                    v.x += -ry * speedMult * 0.1;
                    v.y += rx * speedMult * 0.1;
                    v.z -= (pz - chargeCenter.z) * 0.05; // ç¨å¾®å‹æ‰åœ¨Zè½´
                }

                v.x += (Math.random()-0.5) * 0.2; 
                v.y += (Math.random()-0.5) * 0.2;
                v.z += (Math.random()-0.5) * 0.2;

                const damping = 0.85; // é˜»å°¼ç¨å¾®å°ç‚¹ï¼Œè®©ç²’å­æ›´æ»‘
                v.x *= damping; v.y *= damping; v.z *= damping;

                positions[idx] += v.x;
                positions[idx+1] += v.y;
                positions[idx+2] += v.z;
                
                // é™åˆ¶èŒƒå›´
                if (isCharging) {
                    const dx = positions[idx] - effectiveAttractPoint.x;
                    const dy = positions[idx+1] - effectiveAttractPoint.y;
                    const dz = positions[idx+2] - effectiveAttractPoint.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    // æ‹‰å¼€è·ç¦»è¶Šå¤§ï¼Œåœˆå­å¯ä»¥ç¨å¾®å¤§ä¸€ç‚¹ç‚¹
                    const dynamicSpread = spread * (1 + dragSpeedFactor * 0.3);
                    if (dist > dynamicSpread * 2.0) {
                        const ratio = (dynamicSpread * 2.0) / dist;
                        positions[idx] = effectiveAttractPoint.x + dx * ratio;
                        positions[idx+1] = effectiveAttractPoint.y + dy * ratio;
                        positions[idx+2] = effectiveAttractPoint.z + dz * ratio;
                    }
                }
            }
            this.geo.attributes.position.needsUpdate = true;
        }
    }

    class MorphingParticleSystem {
        constructor() {
            this.count = CONFIG.morphParticleCount;
            this.geo = new THREE.BufferGeometry();
            const pos = new Float32Array(this.count * 3);
            const cols = new Float32Array(this.count * 3);
            const sizes = new Float32Array(this.count);

            this.targets = { heart: new Float32Array(this.count * 3), texts: [] };

            const cA = new THREE.Color(CONFIG.heartColorA);
            const cB = new THREE.Color(CONFIG.heartColorB);
            for(let i=0; i<this.count; i++) {
                pos[i*3] = (Math.random()-0.5)*300; 
                pos[i*3+1] = (Math.random()-0.5)*300;
                pos[i*3+2] = (Math.random()-0.5)*300;
                const ratio = Math.random();
                const c = cA.clone().lerp(cB, ratio);
                // å¢å¼ºé¢œè‰²äº®åº¦
                c.multiplyScalar(1.4);
                cols[i*3] = c.r; cols[i*3+1] = c.g; cols[i*3+2] = c.b;
                sizes[i] = Math.random() * 1.5 + 0.5;
            }

            this.generateHeartTargets();
            this.generateTextTargets();

            this.geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            this.geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));
            this.geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            this.mat = new THREE.PointsMaterial({
                vertexColors: true, size: 1.0, map: commonTexture,
                transparent: true, opacity: 0, blending: THREE.AdditiveBlending, depthWrite: false
            });

            this.mesh = new THREE.Points(this.geo, this.mat);
            scene.add(this.mesh);

            this.animState = 'HIDDEN';
            this.beatCount = 0;
            this.textIndex = 0;
        }

        generateHeartTargets() {
            for(let i=0; i<this.count; i++) {
                const t = Math.random() * Math.PI * 2;
                const r = Math.pow(Math.random(), 0.3);
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 8 * r;
                x *= r * 1.5; y *= r * 1.5; // å¿ƒå½¢ä¹Ÿæ”¾å¤§
                if(isMobile) { x *= 1.2; y *= 1.2; } // æ‰‹æœºå†å¤§ç‚¹
                
                this.targets.heart[i*3] = x;
                this.targets.heart[i*3+1] = y;
                this.targets.heart[i*3+2] = z;
            }
        }

        generateTextTargets() {
            const canvas = document.getElementById('textCanvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const w = canvas.width; const h = canvas.height;

            CONFIG.textPhrases.forEach((phrase, index) => {
                ctx.clearRect(0,0,w,h);
                ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);
                ctx.fillStyle = '#fff';
                
                const baseFontSize = isMobile ? 70 : 50;
                ctx.font = `bold ${baseFontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const maxWidth = w * 0.9;
                const lineHeight = baseFontSize * 1.2;
                const words = phrase.split('');
                let lines = [];
                let currentLine = words[0];

                for (let i = 1; i < words.length; i++) {
                    const char = words[i];
                    const width = ctx.measureText(currentLine + char).width;
                    if (width < maxWidth) {
                        currentLine += char;
                    } else {
                        lines.push(currentLine);
                        currentLine = char;
                    }
                }
                lines.push(currentLine);

                const totalHeight = lines.length * lineHeight;
                const startY = (h - totalHeight) / 2 + (lineHeight / 2);

                lines.forEach((line, i) => {
                    ctx.fillText(line, w/2, startY + i * lineHeight);
                });

                const data = ctx.getImageData(0,0,w,h).data;
                const validPixels = [];
                const step = isMobile ? 5 : 4;
                for(let y=0; y<h; y+=step) { 
                    for(let x=0; x<w; x+=step) {
                        if(data[(y*w+x)*4] > 128) validPixels.push({x,y});
                    }
                }
                
                const textTarget = new Float32Array(this.count * 3);
                for(let i=0; i<this.count; i++) {
                    const p = validPixels[i % validPixels.length] || {x:w/2, y:h/2};
                    textTarget[i*3] = (p.x / w - 0.5) * 90;
                    textTarget[i*3+1] = -(p.y / h - 0.5) * 50;
                    
                    // ã€æ ¸å¿ƒä¿®æ”¹ã€‘å°† Z è½´åšåº¦ä» 5 é™ä½åˆ° 0.1 
                    // è¿™æ ·ç²’å­å‡ ä¹åœ¨åŒä¸€å¹³é¢ï¼Œæ¶ˆé™¤äº†é€è§†å¸¦æ¥çš„å¤§å°ä¸ä¸€ï¼Œè®©å­—è¿¹æ›´æ¸…æ™°é”åˆ© 
                    textTarget[i*3+2] = (Math.random()-0.5) * 1;
                }
                this.targets.texts.push(textTarget);
            });
        }

        startSequence() {
            this.animState = 'BEATING';
            this.beatCount = 0;
            this.textIndex = 0;
            this.mat.opacity = 1;
            const pos = this.geo.attributes.position.array;
            for(let i=0; i<pos.length; i++) pos[i] = 0;
            this.geo.attributes.position.needsUpdate = true;
        }

        update(time, dt) {
            if (this.animState === 'HIDDEN') {
                this.mat.opacity *= 0.95;
                return;
            }

            const positions = this.geo.attributes.position.array;
            let currentTargets;
            let beatScale = 1.0;
            let lerpFactor = 0.08;

            switch(this.animState) {
                case 'BEATING':
                    currentTargets = this.targets.heart;
                    const beatFreq = 3.5;
                    const sineVal = Math.sin(time * beatFreq);
                    beatScale = 1 + Math.pow(sineVal, 8) * 0.15;
                    
                    if (sineVal < -0.8 && !this.beatFlag) {
                        this.beatCount++;
                        this.beatFlag = true;
                        if (this.beatCount >= CONFIG.beatsToPerform) {
                            this.animState = 'SHOWING_TEXT';
                            this.lastStateChangeTime = time;
                            this.textIndex = 0; 
                        }
                    } else if (sineVal > 0) {
                        this.beatFlag = false;
                    }
                    break;

                case 'SHOWING_TEXT':
                    if (this.textIndex < this.targets.texts.length) {
                        currentTargets = this.targets.texts[this.textIndex];
                    } else {
                        currentTargets = this.targets.heart; 
                    }
                    lerpFactor = 0.05; 
                    const timeInState = time - this.lastStateChangeTime;
                    if (timeInState > CONFIG.textDisplayTime) {
                        this.textIndex++;
                        this.lastStateChangeTime = time; 
                        if (this.textIndex >= CONFIG.textPhrases.length) {
                            this.animState = 'BEATING';
                            this.beatCount = 0;
                            this.textIndex = 0;
                        }
                    }
                    break;
            }

            for(let i=0; i<this.count; i++) {
                const idx = i*3;
                let tx = currentTargets ? currentTargets[idx] : 0;
                let ty = currentTargets ? currentTargets[idx+1] : 0;
                let tz = currentTargets ? currentTargets[idx+2] : 0;

                if (this.animState === 'BEATING') {
                    tx *= beatScale; ty *= beatScale; tz *= beatScale;
                    positions[idx] += (tx - positions[idx]) * lerpFactor;
                    positions[idx+1] += (ty - positions[idx+1]) * lerpFactor;
                    positions[idx+2] += (tz - positions[idx+2]) * lerpFactor;
                } else {
                    let dx = tx - positions[idx];
                    let dy = ty - positions[idx+1];
                    let dz = tz - positions[idx+2];
                    const timeInState = time - this.lastStateChangeTime;
                    const swirlIntensity = 0.8 * Math.max(0, 0.5 - (timeInState * 0.5));
                    
                    positions[idx] += dx * lerpFactor - dy * swirlIntensity * 0.1;
                    positions[idx+1] += dy * lerpFactor + dx * swirlIntensity * 0.1;
                    positions[idx+2] += dz * lerpFactor;
                    
                    positions[idx] += Math.sin(time * 3 + positions[idx+1]*0.05) * 0.02;
                }
                positions[idx] += (Math.random()-0.5)*0.1;
                positions[idx+1] += (Math.random()-0.5)*0.1;
                positions[idx+2] += (Math.random()-0.5)*0.1;
            }
            this.geo.attributes.position.needsUpdate = true;
            this.mesh.rotation.y = Math.sin(time * 0.2) * 0.1;
        }
    }

    function animate() {
        if(!isRunning) return;
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        const dt = clock.getDelta();

        const isCharging = currentState === STATE.CHARGING;
        const progress = chargeCounter / CONFIG.gestureHoldTime;

        if (isMobile) {
            // æ‰‹æœºé€»è¾‘
            // æŒ‰é’®é»˜è®¤ä½ç½® (3D)
            let lTarget = new THREE.Vector3(-20, -30, 0); 
            let rTarget = new THREE.Vector3(20, -30, 0);
            
            // ä¼ é€’ dragFactor å½±å“æ—‹è½¬é€Ÿåº¦
            handL.update(lTarget, touchState.leftPressed, isCharging, gestureCenter, progress, touchState.dragFactor);
            handR.update(rTarget, touchState.rightPressed, isCharging, gestureCenter, progress, touchState.dragFactor);

            // è¿›åº¦é€»è¾‘ï¼šåªæœ‰æ‹‰å¾—è¶³å¤Ÿè¿œï¼Œè¿›åº¦æ¡æ‰èµ°
            if (isCharging) {
                if (touchState.dragFactor > 0.3) {
                    // æ‹‰å¾—è¶Šè¿œèµ°å¾—è¶Šå¿«ï¼Œä½†æœ‰æœ€å¤§é™åˆ¶
                    const speed = 0.5 + touchState.dragFactor * 1.5; 
                    chargeCounter += speed;
                } else {
                    // æ²¡æ‹‰å¼€å°±æ…¢æ…¢æ‰
                    chargeCounter = Math.max(0, chargeCounter - 1);
                }
                if (chargeCounter > CONFIG.gestureHoldTime) triggerSequence();
            } 

        } else {
            // PC é€»è¾‘
            let lTarget = new THREE.Vector3(-999,0,0);
            let rTarget = new THREE.Vector3(999,0,0);
            let lDetected = false; let rDetected = false;

            if (handsData.length > 0) {
                for(let hand of handsData) {
                    const pos = mapToWorld(hand[9].x, hand[9].y);
                    if (hand[9].x > 0.5) { lTarget.copy(pos); lDetected = true; } 
                    else { rTarget.copy(pos); rDetected = true; }
                }
            }
            handL.update(lTarget, lDetected, isCharging, gestureCenter, progress);
            handR.update(rTarget, rDetected, isCharging, gestureCenter, progress);
        }

        morphSystem.update(time, dt);
        updateUI(progress);
        composer.render();
    }

    function updateUI(progress) {
        const hint = document.getElementById('ui-hint');
        const barBg = document.getElementById('progress-bar-bg');
        const bar = document.getElementById('progress-bar');
        
        if (currentState === STATE.ACTIVE) {
            hint.style.opacity = 0; barBg.style.opacity = 0; 
            document.getElementById('mobile-controls').style.opacity = 0; 
            return;
        }
        hint.style.opacity = 1;

        if (isMobile) {
            if (currentState === STATE.CHARGING) {
                // æ ¹æ®æ‹‰å¼€ç¨‹åº¦æç¤º
                if (touchState.dragFactor < 0.3) {
                    hint.innerText = "å†å¾€ä¸¤è¾¹æ‹‰ä¸€ç‚¹ï¼";
                    barBg.style.opacity = 0.5;
                } else if (touchState.dragFactor < 0.8) {
                    hint.innerText = "èƒ½é‡æ³¨å…¥ä¸­...";
                    barBg.style.opacity = 1;
                } else {
                    hint.innerText = "ä¿æŒå…¨åŠŸç‡è¾“å‡ºï¼";
                    barBg.style.opacity = 1;
                }
                bar.style.width = (Math.min(1, progress) * 100) + '%';
            } else if (currentState === STATE.ALIGNING) {
                hint.innerText = "åŒæ—¶æŒ‰ä½ä¸¤ä¸ªæŒ‰é’®";
                barBg.style.opacity = 1; bar.style.width = '0%';
            } else {
                // ã€ä¿®æ”¹ã€‘ï¼šè¿™é‡ŒåŸæ¥çš„æç¤ºè¯­æ”¹æˆä¸‹é¢çš„ 
                hint.innerText = "æŒ‰ä½æŒ‰é’® é¡ºç€æ‰‹æœºé•¿è¾¹æ‹‰å¼€";
                barBg.style.opacity = 0;
            }
        } else {
            if (currentState === STATE.CHARGING) {
                hint.innerText = "Hold & Charge...";
                barBg.style.opacity = 1;
                bar.style.width = (progress * 100) + '%';
            } else if (currentState === STATE.ALIGNING) {
                hint.innerText = "Connect Fingertips";
                barBg.style.opacity = 1; bar.style.width = '0%';
            } else if (currentState === STATE.SEARCHING) {
                hint.innerText = "Wave Hands / Form Heart";
                barBg.style.opacity = 0;
            }
        }
    }

    function mapToWorld(x, y) {
        const w = 75; const h = 55; 
        const wx = (0.5 - x) * w; const wy = (0.5 - y) * h;
        return new THREE.Vector3(wx, wy, 0);
    }

    function onHandResults(results) {
        handsData = results.multiHandLandmarks;
        if (currentState === STATE.ACTIVE) return;

        if (handsData.length === 2) {
            let h1 = handsData[0]; let h2 = handsData[1];
            let leftHand, rightHand;
            if (h1[0].x > h2[0].x) { leftHand = h1; rightHand = h2; } else { leftHand = h2; rightHand = h1; }

            const lIdx = mapToWorld(leftHand[8].x, leftHand[8].y);
            const rIdx = mapToWorld(rightHand[8].x, rightHand[8].y);
            const lThumb = mapToWorld(leftHand[4].x, leftHand[4].y);
            const rThumb = mapToWorld(rightHand[4].x, rightHand[4].y);
            gestureCenter.copy(lIdx).add(rIdx).multiplyScalar(0.5);

            const topDist = lIdx.distanceTo(rIdx);
            const bottomDist = lThumb.distanceTo(rThumb);

            if (topDist < CONFIG.connectThreshold && bottomDist < CONFIG.connectThreshold) {
                currentState = STATE.CHARGING;
                chargeCounter++;
                if (chargeCounter > CONFIG.gestureHoldTime) triggerSequence();
            } else {
                if (topDist < 15 && bottomDist < 15) currentState = STATE.ALIGNING;
                else currentState = STATE.SEARCHING;
                chargeCounter = Math.max(0, chargeCounter - 2);
            }
        } else {
            currentState = STATE.SEARCHING; chargeCounter = 0;
        }
    }

    function triggerSequence() {
        currentState = STATE.ACTIVE;
        morphSystem.startSequence();
    }
    
    fetchDecryptedPayload();

</script>
</body>
</html>