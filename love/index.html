<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2026 ä¸“å±æ‰‹åŠ¿ç¥ç¦</title>
    
    <link rel="icon" type="image/x-icon" href="../assets/favicon.ico">
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Microsoft YaHei', sans-serif;
            touch-action: none; 
        }

        #world {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: #000;
            overflow: hidden;
        }

        #three-canvas { display: block; width: 100%; height: 100%; }
        
        /* === è°ƒè¯•é¢„è§ˆçª—å£ === */
        #video-container {
            position: absolute;
            bottom: 20px; left: 20px;
            /* æ‰‹æœºä¸Šç¨å¾®å¤§ä¸€ç‚¹ï¼Œæ–¹ä¾¿çœ‹çº¢çº¿ */
            width: 140px; height: 186px; 
            border: 2px solid rgba(255, 105, 180, 0.5); /* ç²‰è‰²è¾¹æ¡†æç¤ºè¿™æ˜¯è°ƒè¯•åŒº */
            border-radius: 8px;
            overflow: hidden;
            z-index: 10;
            opacity: 0; 
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ï¼Œç¬¦åˆç…§é•œå­ä¹ æƒ¯ */
            pointer-events: none;
            transition: opacity 1s;
            background: #000;
        }
        
        /* è§†é¢‘å±‚ */
        #input_video { 
            position: absolute; top:0; left:0; width: 100%; height: 100%; 
            object-fit: cover; 
        }
        
        /* ç»˜åˆ¶éª¨éª¼å±‚ (å¤©çœ¼) */
        #debug_canvas {
            position: absolute; top:0; left:0; width: 100%; height: 100%; 
            object-fit: cover;
        }

        #ui-container {
            position: absolute;
            top: 70%; left: 0; 
            width: 100%;
            transform: translateY(-50%);
            text-align: center;
            pointer-events: none;
            z-index: 5;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            transition: opacity 1s;
        }

        #ui-hint {
            color: rgba(255, 180, 200, 0.9);
            font-size: 16px; 
            letter-spacing: 2px;
            text-shadow: 0 0 15px rgba(255, 50, 150, 0.6);
            margin-bottom: 20px;
            font-weight: 400;
            text-transform: uppercase;
        }

        #progress-bar-bg {
            width: 150px; height: 3px;
            background: rgba(255,255,255,0.15);
            border-radius: 1.5px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #progress-bar {
            width: 0%; height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff99cc);
            box-shadow: 0 0 15px #ff3366;
            transition: width 0.1s linear;
        }

        #start-container {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            text-align: center;
            width: 100%; 
            transition: opacity 0.8s ease;
        }

        /* å°‘å¥³ç²‰æŒ‰é’® */
        #overlay {
            display: inline-block;
            color: rgba(255, 240, 245, 1);
            font-size: 16px;
            letter-spacing: 4px;
            cursor: pointer;
            background: rgba(80, 20, 40, 0.6); 
            backdrop-filter: blur(12px);
            padding: 18px 40px; 
            border-radius: 100px;
            border: 1px solid rgba(255, 105, 180, 0.4);
            box-shadow: 0 0 30px rgba(255, 20, 147, 0.3);
            transition: transform 0.2s, box-shadow 0.3s, background 0.3s;
            font-weight: 400;
            text-transform: uppercase;
            white-space: nowrap;
            position: relative;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent; 
        }

        #overlay:hover {
            background: rgba(100, 20, 50, 0.7);
            border-color: rgba(255, 182, 193, 0.8);
            box-shadow: 0 0 50px rgba(255, 105, 180, 0.6); 
            transform: scale(1.02);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        #overlay:active { transform: scale(0.95); }

        #overlay::before {
            content: ''; position: absolute;
            top: var(--y, 50%); left: var(--x, 50%);
            transform: translate(-50%, -50%);
            width: 150px; height: 150px;
            background: radial-gradient(circle, rgba(255, 192, 203, 0.4) 0%, transparent 70%);
            opacity: 0; transition: opacity 0.3s;
            pointer-events: none; mix-blend-mode: overlay; 
        }
        #overlay:hover::before { opacity: 1; }

        #start-subtext {
            margin-top: 20px;
            font-size: 11px;
            color: rgba(255, 182, 193, 0.5);
            letter-spacing: 1px;
            cursor: pointer;
            text-decoration: none;
            transition: color 0.3s;
        }

        #watermark {
            position: absolute;
            top: 20px; right: 20px;
            font-size: 10px; 
            color: rgba(255, 255, 255, 0.3);
            letter-spacing: 2px;
            z-index: 5;
            cursor: pointer;
            font-weight: bold;
            pointer-events: auto;
            transition: all 0.3s;
            display: none;
        }

        #end-ad {
            position: absolute;
            bottom: 30px; 
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            width: 80%; 
            max-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            padding: 10px 0;
            text-align: center;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            letter-spacing: 1px;
            cursor: pointer;
            z-index: 8;
            opacity: 0;
            transition: all 0.8s cubic-bezier(0.22, 1, 0.36, 1);
            display: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        #end-ad.visible { opacity: 1; transform: translateX(-50%) translateY(0); }
        
        #loading-text {
            display: none;
            margin-top: 15px; 
            color: rgba(255, 192, 203, 0.6);
            font-size: 12px; letter-spacing: 2px;
        }

        #debug-info {
            position: absolute;
            top: 10px; left: 10px;
            color: lime; font-size: 10px;
            z-index: 100;
            pointer-events: none;
            background: rgba(0,0,0,0.5);
            padding: 2px;
            display: none; /* è°ƒè¯•å®Œå¯å…³é—­ */
        }
    </style>
</head>
<body>

<div id="world">
    <div id="start-container">
        <div id="overlay" onclick="startExperience()" onmousemove="moveGlow(event)" ontouchmove="moveGlow(event)">âœ¨ å¼€å¯ 2026 é­”æ³• âœ¨</div>
        <div id="loading-text">æ­£åœ¨å”¤é†’ AI (æ‰‹æœºè¯·å…è®¸æ‘„åƒå¤´)...</div>
        <div id="start-subtext" onclick="goBuy()">Powered by ä¸ƒå¶æ€€ç‘¾</div>
    </div>

    <div id="ui-container">
        <div id="ui-hint">è¯·ç«–å±å¹¶å°†æ‰‹ä¸¾é«˜</div>
        <div id="progress-bar-bg"><div id="progress-bar"></div></div>
    </div>

    <div id="video-container">
        <video id="input_video" playsinline webkit-playsinline></video>
        <canvas id="debug_canvas"></canvas>
    </div>

    <div id="watermark" onclick="goBuy()">ä¸ƒå¶æ€€ç‘¾</div>
    <div id="end-ad" onclick="goBuy()">
        é€ TA ä¸€å¥ä¸“å±æƒ…è¯ <span style="margin-left:5px; opacity:0.7">ğŸ‘‰ å®šåˆ¶è¡¨ç™½æ–‡å­—</span>
    </div>

    <canvas id="three-canvas"></canvas>
    <canvas id="textCanvas" width="512" height="256" style="display:none;"></canvas>
    
    <div id="debug-info">Init...</div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

    // === æ£€æµ‹æ˜¯å¦ä¸ºæ‰‹æœº ===
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const debugInfo = document.getElementById('debug-info');
    
    // === é…ç½®åŒºåŸŸ ===
    const CONFIG = {
        handCloudColor: 0xff66aa,  
        heartColorA: 0xff0033,     
        heartColorB: 0xff99cc,     

        bloomStrength: isMobile ? 1.0 : 1.4,        
        bloomRadius: 0.4,          
        
        handParticleCount: isMobile ? 800 : 1500,   
        handParticleSize: isMobile ? 3.5 : 2.5,   

        connectThreshold: 4.0,    
        gestureHoldTime: 80, 
        
        morphParticleCount: isMobile ? 12000 : 25000, 
        textPhrases: ["I LOVE U", "FOREVER"], 
        textDisplayTime: 4.0,      
        beatsToPerform: 3,         

        handAttractStrength: 0.5,  
        handSwirlSpeed: 0.6,       
        handSpreadCharging: isMobile ? 5.0 : 7.0,   
        handSpreadNormal: isMobile ? 12.0 : 17.0,    
        
        cameraZ: isMobile ? 90 : 70 
    };

    const BUY_LINK = "../#buy"; 
    const API_DECODE_URL = "https://vimalin.xyz:8443/api/decode"; 
    let isPaidUser = false;

    let scene, camera, renderer, composer;
    let handL, handR; 
    let morphSystem; 
    let clock = new THREE.Clock();

    const STATE = { SEARCHING: 0, ALIGNING: 1, CHARGING: 2, ACTIVE: 3 };
    let currentState = STATE.SEARCHING;
    let chargeCounter = 0;
    let handsData = [];
    let gestureCenter = new THREE.Vector3();
    let isRunning = false; 

    // === å…¨å±€å‡½æ•° ===
    window.goBuy = function() { window.location.href = BUY_LINK; };
    
    window.moveGlow = function(e) {
        const btn = e.currentTarget;
        const rect = btn.getBoundingClientRect();
        let clientX = e.clientX;
        let clientY = e.clientY;
        if(e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        }
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        btn.style.setProperty('--x', x + 'px');
        btn.style.setProperty('--y', y + 'px');
    };

    window.startExperience = async function() {
        const overlay = document.getElementById('overlay');
        const loadingText = document.getElementById('loading-text');
        
        overlay.style.display = 'none';
        loadingText.style.display = 'block';

        initThreeJS();
        try {
            loadingText.innerText = "æ­£åœ¨åŠ è½½ AI æ¨¡å‹...";
            await initMediaPipe();
        } catch (error) {
            console.error(error);
            loadingText.innerText = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥ HTTPS";
            return;
        }

        const startContainer = document.getElementById('start-container');
        startContainer.style.opacity = '0';
        setTimeout(() => startContainer.style.display = 'none', 800);

        // æ˜¾ç¤ºå·¦ä¸‹è§’çš„è°ƒè¯•çª—å£
        document.getElementById('video-container').style.opacity = '0.6';
        document.getElementById('ui-container').style.opacity = '1';
        
        if (!isPaidUser) {
            const ad = document.getElementById('end-ad');
            if(ad) {
                ad.style.display = 'block';
                setTimeout(() => ad.classList.add('visible'), 2000);
            }
        }
        
        isRunning = true;
        animate();
    };

    async function fetchDecryptedPayload() {
        const params = new URLSearchParams(window.location.search);
        const code = params.get('code');
        if (code) {
            try {
                const response = await fetch(API_DECODE_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code: code })
                });
                const result = await response.json();
                if (result.success && result.data && result.data.wish) {
                    isPaidUser = true; 
                    const lines = result.data.wish.split('\n').filter(line => line.trim() !== '');
                    CONFIG.textPhrases = lines;
                    initUI(); 
                }
            } catch (e) { console.error("API Error", e); }
        }
        initUI(); 
    }
    
    function initUI() {
        if (isPaidUser) {
            const wm = document.getElementById('watermark');
            if(wm) wm.style.display = 'none';
            const endAd = document.getElementById('end-ad');
            if(endAd) endAd.style.display = 'none'; 
        } else {
            const wm = document.getElementById('watermark');
            if(wm) wm.style.display = 'block';
        }
    }

    function initThreeJS() {
        const canvas = document.getElementById('three-canvas');
        renderer = new THREE.WebGLRenderer({ canvas, antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio, 2));

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050008, 0.015);

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, CONFIG.cameraZ);

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = CONFIG.bloomStrength;
        bloomPass.radius = CONFIG.bloomRadius;
        bloomPass.threshold = 0.1;

        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        handL = new SwirlHandCloud(CONFIG.handCloudColor);
        handR = new SwirlHandCloud(CONFIG.handCloudColor);
        morphSystem = new MorphingParticleSystem();

        window.addEventListener('resize', onResize);
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    // === ã€æ ¸å¿ƒä¿®æ”¹ã€‘MediaPipe åˆå§‹åŒ– ===
    async function initMediaPipe() {
        const videoElement = document.getElementById('input_video');
        const debugCanvas = document.getElementById('debug_canvas');
        const debugCtx = debugCanvas.getContext('2d');

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 2, 
            modelComplexity: 1, // æ‰‹æœºä¸Šä¹Ÿä½¿ç”¨ 1ï¼Œé˜²æ­¢ Lite ç‰ˆæœ¬åœ¨æŸäº›å…‰çº¿ä¸‹å¤ªè ¢
            minDetectionConfidence: 0.5, 
            minTrackingConfidence: 0.5
        });
        
        hands.onResults((results) => {
            // 1. å°†æ•°æ®ä¼ ç»™ Three.js
            onResults(results);

            // 2. ã€æ–°å¢ã€‘åœ¨å·¦ä¸‹è§’ç”»å‡ºçº¢è‰²çš„æ‰‹éƒ¨éª¨éª¼ (å¤©çœ¼åŠŸèƒ½)
            debugCtx.save();
            debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
            debugCtx.drawImage(results.image, 0, 0, debugCanvas.width, debugCanvas.height);
            
            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(debugCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2}); // ç»¿è‰²éª¨éª¼
                    drawLandmarks(debugCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2}); // çº¢è‰²å…³èŠ‚
                }
            }
            debugCtx.restore();
            
            // æ›´æ–°è°ƒè¯•ä¿¡æ¯
            debugInfo.innerText = `Hands: ${results.multiHandLandmarks.length}`;
        });
        
        // ã€å…³é”®ã€‘ä¸ºæ‰‹æœºè®¾ç½®ç«–å±åˆ†è¾¨ç‡ï¼Œä¸è¦ç”¨ 320x240
        const w = isMobile ? 360 : 640;
        const h = isMobile ? 480 : 480;

        const cameraUtils = new Camera(videoElement, { 
            onFrame: async () => { await hands.send({image: videoElement}); }, 
            width: w, 
            height: h,
            facingMode: 'user'
        });
        
        // è®¾ç½®ç”»å¸ƒå°ºå¯¸åŒ¹é…è§†é¢‘
        videoElement.onloadedmetadata = () => {
             debugCanvas.width = videoElement.videoWidth;
             debugCanvas.height = videoElement.videoHeight;
        };
        
        await cameraUtils.start();
    }

    function createSoftTexture() {
        const c = document.createElement('canvas'); c.width=64; c.height=64;
        const ctx = c.getContext('2d');
        const g = ctx.createRadialGradient(32,32,0,32,32,32);
        g.addColorStop(0, 'rgba(255,255,255,1)');
        g.addColorStop(0.4, 'rgba(255,220,230,0.3)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g; ctx.fillRect(0,0,64,64);
        return new THREE.CanvasTexture(c);
    }
    const commonTexture = createSoftTexture();

    class SwirlHandCloud {
        constructor(color) {
            this.count = CONFIG.handParticleCount;
            this.geo = new THREE.BufferGeometry();
            const pos = new Float32Array(this.count*3);
            const sizes = new Float32Array(this.count);
            const colors = new Float32Array(this.count*3);
            const c = new THREE.Color(color);

            for(let i=0; i<this.count; i++) {
                pos[i*3] = 0; pos[i*3+1] = 0; pos[i*3+2] = 0;
                sizes[i] = Math.random() * (CONFIG.handParticleSize * 0.8) + (CONFIG.handParticleSize * 0.2);
                colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
            }

            this.geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            this.geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            this.geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            this.mat = new THREE.PointsMaterial({
                vertexColors: true, size: 1.0, map: commonTexture,
                transparent: true, opacity: 0, blending: THREE.AdditiveBlending, depthWrite: false
            });

            this.mesh = new THREE.Points(this.geo, this.mat);
            scene.add(this.mesh);

            this.velocities = [];
            for(let i=0; i<this.count; i++) this.velocities.push({x:0, y:0, z:0});
        }

        update(targetPos, isDetected, isCharging, chargeCenter, progress) {
            const positions = this.geo.attributes.position.array;
            const targetOpacity = (isDetected && currentState !== STATE.ACTIVE) ? 0.8 : 0;
            this.mat.opacity += (targetOpacity - this.mat.opacity) * 0.1;
            if (this.mat.opacity < 0.01) return;

            const spread = isCharging ? CONFIG.handSpreadCharging : CONFIG.handSpreadNormal;
            const attractStrength = isCharging ? CONFIG.handAttractStrength : 0.08; 
            const attractPoint = isCharging ? chargeCenter : targetPos;

            for(let i=0; i<this.count; i++) {
                const idx = i*3;
                const v = this.velocities[i];
                const px = positions[idx]; const py = positions[idx+1]; const pz = positions[idx+2];

                v.x += (attractPoint.x - px) * attractStrength * 0.1;
                v.y += (attractPoint.y - py) * attractStrength * 0.1;
                v.z += (attractPoint.z - pz) * attractStrength * 0.1;

                if (isCharging) {
                    const swirlSpeed = CONFIG.handSwirlSpeed + progress * 0.5;
                    const rx = px - chargeCenter.x;
                    const ry = py - chargeCenter.y;
                    v.x += -ry * swirlSpeed * 0.1;
                    v.y += rx * swirlSpeed * 0.1;
                    v.z -= (pz - chargeCenter.z) * 0.1; 
                }

                v.x += (Math.random()-0.5) * 0.2; 
                v.y += (Math.random()-0.5) * 0.2;
                v.z += (Math.random()-0.5) * 0.2;

                const damping = 0.8;
                v.x *= damping; v.y *= damping; v.z *= damping;

                positions[idx] += v.x;
                positions[idx+1] += v.y;
                positions[idx+2] += v.z;
                
                if (isCharging) {
                    const dx = positions[idx] - attractPoint.x;
                    const dy = positions[idx+1] - attractPoint.y;
                    const dz = positions[idx+2] - attractPoint.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist > spread * 2.0) {
                            const ratio = (spread * 2.0) / dist;
                            positions[idx] = attractPoint.x + dx * ratio;
                            positions[idx+1] = attractPoint.y + dy * ratio;
                            positions[idx+2] = attractPoint.z + dz * ratio;
                    }
                }
            }
            this.geo.attributes.position.needsUpdate = true;
        }
    }

    class MorphingParticleSystem {
        constructor() {
            this.count = CONFIG.morphParticleCount;
            this.geo = new THREE.BufferGeometry();
            const pos = new Float32Array(this.count * 3);
            const cols = new Float32Array(this.count * 3);
            const sizes = new Float32Array(this.count);

            this.targets = { heart: new Float32Array(this.count * 3), texts: [] };

            const cA = new THREE.Color(CONFIG.heartColorA);
            const cB = new THREE.Color(CONFIG.heartColorB);
            for(let i=0; i<this.count; i++) {
                pos[i*3] = (Math.random()-0.5)*300; 
                pos[i*3+1] = (Math.random()-0.5)*300;
                pos[i*3+2] = (Math.random()-0.5)*300;
                const ratio = Math.random();
                const c = cA.clone().lerp(cB, ratio);
                cols[i*3] = c.r; cols[i*3+1] = c.g; cols[i*3+2] = c.b;
                sizes[i] = Math.random() * 1.5 + 0.5;
            }

            this.generateHeartTargets();
            this.generateTextTargets();

            this.geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            this.geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));
            this.geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            this.mat = new THREE.PointsMaterial({
                vertexColors: true, size: 1.0, map: commonTexture,
                transparent: true, opacity: 0, blending: THREE.AdditiveBlending, depthWrite: false
            });

            this.mesh = new THREE.Points(this.geo, this.mat);
            scene.add(this.mesh);

            this.animState = 'HIDDEN';
            this.beatCount = 0;
            this.textIndex = 0;
            this.lastStateChangeTime = 0; 
        }

        generateHeartTargets() {
            for(let i=0; i<this.count; i++) {
                const t = Math.random() * Math.PI * 2;
                const r = Math.pow(Math.random(), 0.3);
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 8 * r;
                x *= r * 1.3; y *= r * 1.3;
                this.targets.heart[i*3] = x;
                this.targets.heart[i*3+1] = y;
                this.targets.heart[i*3+2] = z;
            }
        }

        generateTextTargets() {
            const canvas = document.getElementById('textCanvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const w = canvas.width; const h = canvas.height;

            CONFIG.textPhrases.forEach((phrase, index) => {
                ctx.clearRect(0,0,w,h);
                ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);
                ctx.fillStyle = '#fff';
                
                // === ä¿®æ”¹å¼€å§‹ï¼šè‡ªåŠ¨æ¢è¡Œé€»è¾‘ ===
                const baseFontSize = 50; // åŸºç¡€å­—å·
                ctx.font = `bold ${baseFontSize}px Arial`;
                ctx.textAlign = 'center'; 
                ctx.textBaseline = 'middle';

                const maxWidth = w * 0.9; // ç•™å‡º10%è¾¹è·
                const lineHeight = baseFontSize * 1.2;
                const words = phrase.split(''); // æŒ‰å­—åˆ†å‰²ï¼ˆå…¼å®¹ä¸­æ–‡å’Œè‹±æ–‡ï¼‰ï¼Œå¦‚æœæ˜¯çº¯è‹±æ–‡å¯ä»¥ç”¨ ' '
                let lines = [];
                let currentLine = words[0];

                // é€å­—æµ‹é‡å®½åº¦ï¼Œå†³å®šæ˜¯å¦æ¢è¡Œ
                for (let i = 1; i < words.length; i++) {
                    const char = words[i];
                    const width = ctx.measureText(currentLine + char).width;
                    if (width < maxWidth) {
                        currentLine += char;
                    } else {
                        lines.push(currentLine);
                        currentLine = char;
                    }
                }
                lines.push(currentLine);

                // è®¡ç®—å‚ç›´å±…ä¸­çš„èµ·å§‹ä½ç½®
                const totalHeight = lines.length * lineHeight;
                const startY = (h - totalHeight) / 2 + (lineHeight / 2);

                // ç»˜åˆ¶æ¯ä¸€è¡Œ
                lines.forEach((line, i) => {
                    ctx.fillText(line, w/2, startY + i * lineHeight);
                });
                // === ä¿®æ”¹ç»“æŸ ===

                const data = ctx.getImageData(0,0,w,h).data;
                const validPixels = [];
                const step = isMobile ? 5 : 4;
                for(let y=0; y<h; y+=step) { 
                    for(let x=0; x<w; x+=step) {
                        if(data[(y*w+x)*4] > 128) validPixels.push({x,y});
                    }
                }
                
                const textTarget = new Float32Array(this.count * 3);
                for(let i=0; i<this.count; i++) {
                    // å¦‚æœåƒç´ ç‚¹ä¸å¤Ÿï¼ˆæ–‡å­—å¾ˆå°‘ï¼‰ï¼Œéšæœºå–ç‚¹å¡«è¡¥
                    const p = validPixels[i % validPixels.length] || {x:w/2, y:h/2};
                    textTarget[i*3] = (p.x / w - 0.5) * 80;
                    textTarget[i*3+1] = -(p.y / h - 0.5) * 40;
                    textTarget[i*3+2] = (Math.random()-0.5) * 2; 
                }
                this.targets.texts.push(textTarget);
            });
        }

        startSequence() {
            this.animState = 'BEATING';
            this.beatCount = 0;
            this.textIndex = 0;
            this.mat.opacity = 1;
            const pos = this.geo.attributes.position.array;
            for(let i=0; i<pos.length; i++) pos[i] = 0;
            this.geo.attributes.position.needsUpdate = true;
        }

        update(time, dt) {
            if (this.animState === 'HIDDEN') {
                this.mat.opacity *= 0.95;
                return;
            }

            const positions = this.geo.attributes.position.array;
            let currentTargets;
            let beatScale = 1.0;
            let lerpFactor = 0.08;

            switch(this.animState) {
                case 'BEATING':
                    currentTargets = this.targets.heart;
                    const beatFreq = 3.5;
                    const sineVal = Math.sin(time * beatFreq);
                    beatScale = 1 + Math.pow(sineVal, 8) * 0.15;
                    
                    if (sineVal < -0.8 && !this.beatFlag) {
                        this.beatCount++;
                        this.beatFlag = true;
                        if (this.beatCount >= CONFIG.beatsToPerform) {
                            this.animState = 'SHOWING_TEXT';
                            this.lastStateChangeTime = time;
                            this.textIndex = 0; 
                        }
                    } else if (sineVal > 0) {
                        this.beatFlag = false;
                    }
                    break;

                case 'SHOWING_TEXT':
                    if (this.textIndex < this.targets.texts.length) {
                        currentTargets = this.targets.texts[this.textIndex];
                    } else {
                        currentTargets = this.targets.heart; 
                    }
                    lerpFactor = 0.05; 
                    const timeInState = time - this.lastStateChangeTime;
                    if (timeInState > CONFIG.textDisplayTime) {
                        this.textIndex++;
                        this.lastStateChangeTime = time; 
                        if (this.textIndex >= CONFIG.textPhrases.length) {
                            this.animState = 'BEATING';
                            this.beatCount = 0;
                            this.textIndex = 0;
                        }
                    }
                    break;
            }

            for(let i=0; i<this.count; i++) {
                const idx = i*3;
                let tx = currentTargets ? currentTargets[idx] : 0;
                let ty = currentTargets ? currentTargets[idx+1] : 0;
                let tz = currentTargets ? currentTargets[idx+2] : 0;

                if (this.animState === 'BEATING') {
                    tx *= beatScale; ty *= beatScale; tz *= beatScale;
                    positions[idx] += (tx - positions[idx]) * lerpFactor;
                    positions[idx+1] += (ty - positions[idx+1]) * lerpFactor;
                    positions[idx+2] += (tz - positions[idx+2]) * lerpFactor;
                } else {
                    let dx = tx - positions[idx];
                    let dy = ty - positions[idx+1];
                    let dz = tz - positions[idx+2];
                    const timeInState = time - this.lastStateChangeTime;
                    const swirlIntensity = 0.8 * Math.max(0, 0.5 - (timeInState * 0.5));
                    
                    positions[idx] += dx * lerpFactor - dy * swirlIntensity * 0.1;
                    positions[idx+1] += dy * lerpFactor + dx * swirlIntensity * 0.1;
                    positions[idx+2] += dz * lerpFactor;
                    
                    positions[idx] += Math.sin(time * 3 + positions[idx+1]*0.05) * 0.02;
                }
                positions[idx] += (Math.random()-0.5)*0.1;
                positions[idx+1] += (Math.random()-0.5)*0.1;
                positions[idx+2] += (Math.random()-0.5)*0.1;
            }
            this.geo.attributes.position.needsUpdate = true;
            this.mesh.rotation.y = Math.sin(time * 0.2) * 0.1;
        }
    }

    function animate() {
        if(!isRunning) return;
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        const dt = clock.getDelta();

        const isCharging = currentState === STATE.CHARGING;
        const progress = chargeCounter / CONFIG.gestureHoldTime;

        let lTarget = new THREE.Vector3(-999,0,0);
        let rTarget = new THREE.Vector3(999,0,0);
        let lDetected = false; let rDetected = false;

        if (handsData.length > 0) {
            for(let hand of handsData) {
                const pos = mapToWorld(hand[9].x, hand[9].y);
                if (hand[9].x > 0.5) { lTarget.copy(pos); lDetected = true; } 
                else { rTarget.copy(pos); rDetected = true; }
            }
        }

        handL.update(lTarget, lDetected, isCharging, gestureCenter, progress);
        handR.update(rTarget, rDetected, isCharging, gestureCenter, progress);
        
        morphSystem.update(time, dt);
        updateUI(progress, lDetected, rDetected);
        composer.render();
    }

    function updateUI(progress, lDetected, rDetected) {
        const hint = document.getElementById('ui-hint');
        const barBg = document.getElementById('progress-bar-bg');
        const bar = document.getElementById('progress-bar');
        
        if (currentState === STATE.ACTIVE) {
            hint.style.opacity = 0; barBg.style.opacity = 0; return;
        }
        hint.style.opacity = 1;

        if (!lDetected && !rDetected) {
            hint.innerText = "Wave Hands to Summon";
            barBg.style.opacity = 0; chargeCounter = 0;
        } else if ((lDetected && !rDetected) || (!lDetected && rDetected)) {
            hint.innerText = "Need Two Hands";
            barBg.style.opacity = 0; chargeCounter = 0;
        } else {
            if (currentState === STATE.CHARGING) {
                hint.innerText = "Hold & Charge...";
                barBg.style.opacity = 1;
                bar.style.width = (progress * 100) + '%';
            } else if (currentState === STATE.ALIGNING) {
                hint.innerText = "Connect Fingertips";
                barBg.style.opacity = 1; bar.style.width = '0%';
            } else {
                hint.innerText = "Form Heart Shape";
                barBg.style.opacity = 0;
            }
        }
    }

    function mapToWorld(x, y) {
        // æ‰‹æœºä¸Šçš„åæ ‡æ˜ å°„è°ƒæ•´
        const w = isMobile ? 50 : 75; 
        const h = isMobile ? 80 : 55; 
        const wx = (0.5 - x) * w; 
        const wy = (0.5 - y) * h;
        return new THREE.Vector3(wx, wy, 0);
    }

    function onResults(results) {
        handsData = results.multiHandLandmarks;
        if (currentState === STATE.ACTIVE) return;

        if (handsData.length === 2) {
            let h1 = handsData[0]; let h2 = handsData[1];
            let leftHand, rightHand;
            if (h1[0].x > h2[0].x) { leftHand = h1; rightHand = h2; } else { leftHand = h2; rightHand = h1; }

            const lIdx = mapToWorld(leftHand[8].x, leftHand[8].y);
            const rIdx = mapToWorld(rightHand[8].x, rightHand[8].y);
            const lThumb = mapToWorld(leftHand[4].x, leftHand[4].y);
            const rThumb = mapToWorld(rightHand[4].x, rightHand[4].y);
            gestureCenter.copy(lIdx).add(rIdx).multiplyScalar(0.5);

            const topDist = lIdx.distanceTo(rIdx);
            const bottomDist = lThumb.distanceTo(rThumb);

            if (topDist < CONFIG.connectThreshold && bottomDist < CONFIG.connectThreshold) {
                currentState = STATE.CHARGING;
                chargeCounter++;
                if (chargeCounter > CONFIG.gestureHoldTime) triggerSequence();
            } else {
                if (topDist < 15 && bottomDist < 15) currentState = STATE.ALIGNING;
                else currentState = STATE.SEARCHING;
                chargeCounter = Math.max(0, chargeCounter - 2);
            }
        } else {
            currentState = STATE.SEARCHING; chargeCounter = 0;
        }
    }

    function triggerSequence() {
        currentState = STATE.ACTIVE;
        morphSystem.startSequence();
    }
    
    fetchDecryptedPayload();

</script>
</body>
</html>