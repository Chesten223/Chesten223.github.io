<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical Love Particle Loop</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Helvetica Neue', Arial, sans-serif; }
        
        #video-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: hidden;
            z-index: 10;
            opacity: 0.3;
            transform: scaleX(-1);
            pointer-events: none;
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; }
        
        #ui-container {
            position: absolute;
            top: 65%;
            left: 0;
            width: 100%;
            transform: translateY(-50%);
            text-align: center;
            pointer-events: none;
            z-index: 5;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #ui-hint {
            color: rgba(255, 180, 200, 0.9);
            font-size: 18px;
            letter-spacing: 4px;
            text-shadow: 0 0 15px rgba(255, 50, 150, 0.6);
            margin-bottom: 25px;
            font-weight: 400;
            text-transform: uppercase;
        }

        #progress-bar-bg {
            width: 180px;
            height: 3px;
            background: rgba(255,255,255,0.15);
            border-radius: 1.5px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff99cc);
            box-shadow: 0 0 15px #ff3366;
            transition: width 0.1s linear;
        }

        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.6);
            font-size: 14px;
            letter-spacing: 2px;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">INITIALIZING MAGIC...</div>
    
    <div id="ui-container">
        <div id="ui-hint">Wave Hands to Summon</div>
        <div id="progress-bar-bg"><div id="progress-bar"></div></div>
    </div>

    <div id="video-container">
        <video id="input_video"></video>
    </div>

    <canvas id="textCanvas" width="512" height="256" style="display:none;"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        const CONFIG = {
            // --- 颜色配置 ---
            handCloudColor: 0xff77aa, 
            heartColorA: 0xff0055,    
            heartColorB: 0xff99cc,    

            // --- 手部云团配置 ---
            handParticleCount: 1500,   
            handParticleSize: 1.8,     
            handSpreadNormal: 12.0,    
            handSpreadCharging: 1.0,   // 【修改】极度聚拢，变成一个小光球
            
            // --- 变形系统配置 ---
            morphParticleCount: 25000, // 增加粒子数，文字更清晰
            // 【修改】示例文字，两段
            textPhrases: ["I LOVE U", "FOREVER"], 
            // 【修改】每段文字显示2秒
            textDisplayTime: 2.0,      
            // 【修改】爱心跳动3下
            beatsToPerform: 3,         

            // --- 交互阈值 ---
            // 【修改】蓄力时间加长，稍微拖一点时间 (原本90)
            gestureHoldTime: 160,      
            connectThreshold: 8.5,
            
            // --- 视觉效果 ---
            bloomStrength: 1.3,       
            bloomRadius: 0.6,
            cameraZ: 70
        };

        let scene, camera, renderer, composer;
        let handL, handR; 
        let morphSystem; 
        let clock = new THREE.Clock();

        const STATE = { SEARCHING: 0, ALIGNING: 1, CHARGING: 2, ACTIVE: 3 };
        let currentState = STATE.SEARCHING;
        let chargeCounter = 0;

        let handsData = [];
        let gestureCenter = new THREE.Vector3();

        function init() {
            const canvas = document.createElement('canvas');
            document.body.appendChild(canvas);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050008, 0.015);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, CONFIG.cameraZ);

            // 后处理 - 辉光
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = CONFIG.bloomStrength;
            bloomPass.radius = CONFIG.bloomRadius;
            bloomPass.threshold = 0.1;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 初始化系统
            handL = new SwirlHandCloud(CONFIG.handCloudColor);
            handR = new SwirlHandCloud(CONFIG.handCloudColor);
            
            morphSystem = new MorphingParticleSystem();

            window.addEventListener('resize', onResize);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function createSoftTexture() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.4, 'rgba(255,220,230,0.3)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g; ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }
        const commonTexture = createSoftTexture();

        // --- 系统1：旋涡手部云气 (增强向心力版) ---
        class SwirlHandCloud {
            constructor(color) {
                this.count = CONFIG.handParticleCount;
                this.geo = new THREE.BufferGeometry();
                const pos = new Float32Array(this.count*3);
                const sizes = new Float32Array(this.count);
                const colors = new Float32Array(this.count*3);
                
                const c = new THREE.Color(color);

                for(let i=0; i<this.count; i++) {
                    pos[i*3] = 0; pos[i*3+1] = 0; pos[i*3+2] = 0;
                    sizes[i] = Math.random() * CONFIG.handParticleSize + (CONFIG.handParticleSize * 0.5);
                    colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
                }

                this.geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                this.geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                this.geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                this.mat = new THREE.PointsMaterial({
                    vertexColors: true, size: 1.0, map: commonTexture,
                    transparent: true, opacity: 0, blending: THREE.AdditiveBlending, depthWrite: false
                });

                this.mesh = new THREE.Points(this.geo, this.mat);
                scene.add(this.mesh);

                this.velocities = [];
                for(let i=0; i<this.count; i++) this.velocities.push({x:0, y:0, z:0});
            }

            update(targetPos, isDetected, isCharging, chargeCenter, progress) {
                const positions = this.geo.attributes.position.array;
                
                const targetOpacity = (isDetected && currentState !== STATE.ACTIVE) ? 0.7 : 0;
                this.mat.opacity += (targetOpacity - this.mat.opacity) * 0.1;

                if (this.mat.opacity < 0.01) return;

                const spread = isCharging ? CONFIG.handSpreadCharging : CONFIG.handSpreadNormal;
                
                // 【修改】大大增强向心力，让球转得更紧实
                const attractStrength = isCharging ? 1.5 : 0.08; 
                const noiseStrength = isCharging ? 0.05 : 0.8; // 蓄力时几乎没有随机噪点，全是向心

                const attractPoint = isCharging ? chargeCenter : targetPos;

                for(let i=0; i<this.count; i++) {
                    const idx = i*3;
                    const v = this.velocities[i];
                    const px = positions[idx]; const py = positions[idx+1]; const pz = positions[idx+2];

                    // 1. 吸引力
                    v.x += (attractPoint.x - px) * attractStrength * 0.1;
                    v.y += (attractPoint.y - py) * attractStrength * 0.1;
                    v.z += (attractPoint.z - pz) * attractStrength * 0.1;

                    // 2. 旋涡力 (蓄力时转得飞快)
                    if (isCharging) {
                        const swirlSpeed = 0.5 + progress * 0.8; // 【修改】转速加快
                        const rx = px - chargeCenter.x;
                        const ry = py - chargeCenter.y;
                        v.x += -ry * swirlSpeed * 0.1;
                        v.y += rx * swirlSpeed * 0.1;
                        v.z -= (pz - chargeCenter.z) * 0.2; 
                    }

                    // 3. 噪点
                    v.x += (Math.random()-0.5) * noiseStrength;
                    v.y += (Math.random()-0.5) * noiseStrength;
                    v.z += (Math.random()-0.5) * noiseStrength;

                    const damping = isCharging ? 0.7 : 0.8; // 蓄力时阻尼大一点，防止甩飞
                    v.x *= damping; v.y *= damping; v.z *= damping;

                    positions[idx] += v.x;
                    positions[idx+1] += v.y;
                    positions[idx+2] += v.z;
                    
                    // 强力笼子约束
                    if (isCharging) {
                        const dist = attractPoint.distanceTo(new THREE.Vector3(positions[idx], positions[idx+1], positions[idx+2]));
                        if (dist > spread * 3) { // 如果甩太远直接拉回来
                            positions[idx] = positions[idx]*0.8 + attractPoint.x*0.2;
                            positions[idx+1] = positions[idx+1]*0.8 + attractPoint.y*0.2;
                            positions[idx+2] = positions[idx+2]*0.8 + attractPoint.z*0.2;
                        }
                    }
                }
                this.geo.attributes.position.needsUpdate = true;
            }
        }

        // --- 系统2：核心变形系统 (超级好看转场版) ---
        class MorphingParticleSystem {
            constructor() {
                this.count = CONFIG.morphParticleCount;
                this.geo = new THREE.BufferGeometry();
                const pos = new Float32Array(this.count * 3);
                const cols = new Float32Array(this.count * 3);
                const sizes = new Float32Array(this.count);

                this.targets = {
                    heart: new Float32Array(this.count * 3),
                    texts: [] 
                };

                const cA = new THREE.Color(CONFIG.heartColorA);
                const cB = new THREE.Color(CONFIG.heartColorB);
                for(let i=0; i<this.count; i++) {
                    pos[i*3] = (Math.random()-0.5)*200; 
                    pos[i*3+1] = (Math.random()-0.5)*200;
                    pos[i*3+2] = (Math.random()-0.5)*200;

                    const ratio = Math.random();
                    const c = cA.clone().lerp(cB, ratio);
                    cols[i*3] = c.r; cols[i*3+1] = c.g; cols[i*3+2] = c.b;
                    sizes[i] = Math.random() * 1.5 + 0.5;
                }

                this.generateHeartTargets();
                this.generateTextTargets();

                this.geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                this.geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));
                this.geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                this.mat = new THREE.PointsMaterial({
                    vertexColors: true, size: 1.0, map: commonTexture,
                    transparent: true, opacity: 0, blending: THREE.AdditiveBlending, depthWrite: false
                });

                this.mesh = new THREE.Points(this.geo, this.mat);
                scene.add(this.mesh);

                this.animState = 'HIDDEN';
                this.beatCount = 0;
                this.textIndex = 0;
                this.stateTimer = 0;
            }

            generateHeartTargets() {
                for(let i=0; i<this.count; i++) {
                    const t = Math.random() * Math.PI * 2;
                    const r = Math.pow(Math.random(), 0.3);
                    let x = 16 * Math.pow(Math.sin(t), 3);
                    let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    let z = (Math.random() - 0.5) * 8 * r;
                    x *= r * 1.3; y *= r * 1.3;
                    this.targets.heart[i*3] = x;
                    this.targets.heart[i*3+1] = y;
                    this.targets.heart[i*3+2] = z;
                }
            }

            generateTextTargets() {
                const canvas = document.getElementById('textCanvas');
                const ctx = canvas.getContext('2d');
                const w = canvas.width; const h = canvas.height;

                CONFIG.textPhrases.forEach(phrase => {
                    ctx.clearRect(0,0,w,h);
                    ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);
                    ctx.fillStyle = '#fff';
                    // 字体稍微改大一点
                    ctx.font = 'bold 80px Arial';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(phrase, w/2, h/2);

                    const data = ctx.getImageData(0,0,w,h).data;
                    const validPixels = [];
                    for(let y=0; y<h; y+=4) { // 采样步长
                        for(let x=0; x<w; x+=4) {
                            if(data[(y*w+x)*4] > 128) validPixels.push({x,y});
                        }
                    }
                    
                    const textTarget = new Float32Array(this.count * 3);
                    for(let i=0; i<this.count; i++) {
                        const p = validPixels[i % validPixels.length] || {x:w/2, y:h/2};
                        textTarget[i*3] = (p.x / w - 0.5) * 80;
                        textTarget[i*3+1] = -(p.y / h - 0.5) * 40;
                        textTarget[i*3+2] = (Math.random()-0.5) * 2; 
                    }
                    this.targets.texts.push(textTarget);
                });
            }

            startSequence() {
                this.animState = 'BEATING';
                this.beatCount = 0;
                this.textIndex = 0;
                this.mat.opacity = 1;
                const pos = this.geo.attributes.position.array;
                for(let i=0; i<pos.length; i++) pos[i] = 0;
                this.geo.attributes.position.needsUpdate = true;
            }

            update(time, dt) {
                if (this.animState === 'HIDDEN') {
                    this.mat.opacity *= 0.95;
                    return;
                }

                const positions = this.geo.attributes.position.array;
                let currentTargets;
                let beatScale = 1.0;
                
                // 【修改】转场平滑系数，文字阶段更流畅
                let lerpFactor = (this.animState === 'SHOWING_TEXT') ? 0.06 : 0.1;

                // --- 状态机 ---
                switch(this.animState) {
                    case 'BEATING':
                        currentTargets = this.targets.heart;
                        const beatFreq = 3.5; // 心跳稍快
                        beatScale = 1 + Math.pow(Math.sin(time * beatFreq), 8) * 0.15;
                        
                        // 检测心跳
                        if (Math.sin(time * beatFreq) < -0.9 && !this.beatFlag) {
                            this.beatCount++;
                            this.beatFlag = true;
                            // 【关键】数到3下，切换
                            if (this.beatCount >= CONFIG.beatsToPerform) {
                                this.animState = 'SHOWING_TEXT';
                                this.stateTimer = 0;
                            }
                        } else if (Math.sin(time * beatFreq) > 0) {
                            this.beatFlag = false;
                        }
                        break;

                    case 'SHOWING_TEXT':
                        currentTargets = this.targets.texts[this.textIndex];
                        this.stateTimer += dt;
                        // 【关键】2秒显示时间
                        if (this.stateTimer > CONFIG.textDisplayTime) {
                            this.textIndex++;
                            this.stateTimer = 0;
                            // 循环逻辑：文字播完 -> 回到爱心
                            if (this.textIndex >= CONFIG.textPhrases.length) {
                                this.animState = 'BEATING';
                                this.beatCount = 0;
                                this.textIndex = 0;
                            }
                        }
                        break;
                }

                // --- 粒子运动更新 (加入螺旋流场效果) ---
                for(let i=0; i<this.count; i++) {
                    const idx = i*3;
                    let tx = currentTargets[idx];
                    let ty = currentTargets[idx+1];
                    let tz = currentTargets[idx+2];

                    if (this.animState === 'BEATING') {
                        tx *= beatScale; ty *= beatScale; tz *= beatScale;
                        // 爱心状态：简单归位 + 颤动
                        positions[idx] += (tx - positions[idx]) * lerpFactor;
                        positions[idx+1] += (ty - positions[idx+1]) * lerpFactor;
                        positions[idx+2] += (tz - positions[idx+2]) * lerpFactor;
                    } else {
                        // 【关键】文字状态：螺旋汇聚效果 (Super Beautiful)
                        // 计算去往目标的向量
                        let dx = tx - positions[idx];
                        let dy = ty - positions[idx+1];
                        let dz = tz - positions[idx+2];
                        
                        // 添加一个垂直于运动方向的旋转力
                        // 简单的技巧：加上 dx, dy 的旋转分量
                        const swirlIntensity = 0.5 * Math.max(0, 1.0 - this.stateTimer); // 开始时旋转强，后面变弱固定
                        
                        // 螺旋公式
                        positions[idx] += dx * lerpFactor - dy * swirlIntensity * 0.05;
                        positions[idx+1] += dy * lerpFactor + dx * swirlIntensity * 0.05;
                        positions[idx+2] += dz * lerpFactor;

                        // 添加一点正弦波动的漂浮感
                        positions[idx] += Math.sin(time * 2 + positions[idx+1]*0.1) * 0.05;
                    }

                    // 增加微小噪点防止僵硬
                    positions[idx] += (Math.random()-0.5)*0.1;
                    positions[idx+1] += (Math.random()-0.5)*0.1;
                    positions[idx+2] += (Math.random()-0.5)*0.1;
                }
                this.geo.attributes.position.needsUpdate = true;
                
                // 整体稍微转动，增加3D感
                this.mesh.rotation.y = Math.sin(time * 0.2) * 0.1;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            const dt = clock.getDelta();

            const isCharging = currentState === STATE.CHARGING;
            const progress = chargeCounter / CONFIG.gestureHoldTime;

            let lTarget = new THREE.Vector3(-999,0,0);
            let rTarget = new THREE.Vector3(999,0,0);
            let lDetected = false; let rDetected = false;

            if (handsData.length > 0) {
                for(let hand of handsData) {
                    const pos = mapToWorld(hand[9].x, hand[9].y);
                    if (hand[9].x > 0.5) { lTarget.copy(pos); lDetected = true; } 
                    else { rTarget.copy(pos); rDetected = true; }
                }
            }

            handL.update(lTarget, lDetected, isCharging, gestureCenter, progress);
            handR.update(rTarget, rDetected, isCharging, gestureCenter, progress);
            
            morphSystem.update(time, dt);

            updateUI(progress, lDetected, rDetected);
            composer.render();
        }

        function updateUI(progress, lDetected, rDetected) {
            const hint = document.getElementById('ui-hint');
            const barBg = document.getElementById('progress-bar-bg');
            const bar = document.getElementById('progress-bar');
            
            if (currentState === STATE.ACTIVE) {
                hint.style.opacity = 0; barBg.style.opacity = 0; return;
            }
            hint.style.opacity = 1;

            if (!lDetected && !rDetected) {
                hint.innerText = "Wave Hands to Summon";
                barBg.style.opacity = 0; chargeCounter = 0;
            } else if ((lDetected && !rDetected) || (!lDetected && rDetected)) {
                hint.innerText = "Need Two Hands";
                barBg.style.opacity = 0; chargeCounter = 0;
            } else {
                if (currentState === STATE.CHARGING) {
                    hint.innerText = "Hold & Charge...";
                    barBg.style.opacity = 1;
                    bar.style.width = (progress * 100) + '%';
                } else if (currentState === STATE.ALIGNING) {
                    hint.innerText = "Connect Fingertips";
                    barBg.style.opacity = 1; bar.style.width = '0%';
                } else {
                    hint.innerText = "Form Heart Shape";
                    barBg.style.opacity = 0;
                }
            }
        }

        function mapToWorld(x, y) {
            const w = 75; const h = 55; 
            const wx = (0.5 - x) * w; const wy = (0.5 - y) * h;
            return new THREE.Vector3(wx, wy, 0);
        }

        function onResults(results) {
            handsData = results.multiHandLandmarks;
            if (currentState === STATE.ACTIVE) return;

            if (handsData.length === 2) {
                let h1 = handsData[0]; let h2 = handsData[1];
                let leftHand, rightHand;
                if (h1[0].x > h2[0].x) { leftHand = h1; rightHand = h2; } else { leftHand = h2; rightHand = h1; }

                const lIdx = mapToWorld(leftHand[8].x, leftHand[8].y);
                const rIdx = mapToWorld(rightHand[8].x, rightHand[8].y);
                const lThumb = mapToWorld(leftHand[4].x, leftHand[4].y);
                const rThumb = mapToWorld(rightHand[4].x, rightHand[4].y);
                gestureCenter.copy(lIdx).add(rIdx).multiplyScalar(0.5);

                const topDist = lIdx.distanceTo(rIdx);
                const bottomDist = lThumb.distanceTo(rThumb);

                if (topDist < CONFIG.connectThreshold && bottomDist < CONFIG.connectThreshold) {
                    currentState = STATE.CHARGING;
                    chargeCounter++;
                    if (chargeCounter > CONFIG.gestureHoldTime) triggerSequence();
                } else {
                    if (topDist < 15 && bottomDist < 15) currentState = STATE.ALIGNING;
                    else currentState = STATE.SEARCHING;
                    // 只有没对准时才慢慢减少，防止闪烁导致进度清零
                    chargeCounter = Math.max(0, chargeCounter - 2);
                }
            } else {
                currentState = STATE.SEARCHING; chargeCounter = 0;
            }
        }

        function triggerSequence() {
            currentState = STATE.ACTIVE;
            morphSystem.startSequence();
        }

        const videoElement = document.getElementById('input_video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6});
        hands.onResults(onResults);
        const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 320, height: 240 });
        init();
        cameraUtils.start().then(() => { document.getElementById('loading').style.display = 'none'; animate(); });

    </script>
</body>
</html>