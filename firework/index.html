<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2026 ä¸“å±çƒŸèŠ±ç¥ç¦</title>
    
    <link rel="icon" type="image/x-icon" href="../assets/favicon.ico">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205; /* æ·±é‚ƒé»‘èƒŒæ™¯ */
            font-family: 'Microsoft YaHei', sans-serif;
            touch-action: none; 
        }

        #world {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background-color: #020205;
            overflow: hidden;
        }

        canvas { display: block; }
        
        /* === å¯åŠ¨é¡µå®¹å™¨ === */
        #start-container {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
            transition: opacity 0.8s ease;
        }

        /* å¯åŠ¨æŒ‰é’® */
        #overlay {
            display: inline-block;
            color: rgba(255, 255, 255, 0.95);
            font-size: 16px;
            letter-spacing: 4px; /* ç¨å¾®ç¼©å°å­—é—´è·é€‚é…é•¿æ–‡å­— */
            cursor: pointer;
            background: rgba(20, 20, 30, 0.6); 
            backdrop-filter: blur(12px);
            padding: 20px 60px;
            border-radius: 100px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 30px rgba(100, 150, 255, 0.15);
            transition: transform 0.2s, box-shadow 0.3s;
            font-weight: 300;
            text-transform: uppercase;
            white-space: nowrap;
            position: relative;
            overflow: hidden;
        }

        #overlay:hover {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 50px rgba(120, 180, 255, 0.3);
            transform: scale(1.02);
        }
        
        #overlay:active { transform: scale(0.95); }

        /* æŒ‰é’®å…‰æ•ˆ */
        #overlay::before {
            content: ''; position: absolute;
            top: var(--y, 50%); left: var(--x, 50%);
            transform: translate(-50%, -50%);
            width: 150px; height: 150px;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
            opacity: 0; transition: opacity 0.3s;
            pointer-events: none; mix-blend-mode: overlay; 
        }
        #overlay:hover::before { opacity: 1; }

        /* === å¯åŠ¨é¡µä¸‹æ–¹ç‰ˆæƒå°å­— === */
        #start-subtext {
            margin-top: 15px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.4);
            letter-spacing: 1px;
            cursor: pointer;
            text-decoration: none;
            transition: color 0.3s;
        }
        #start-subtext:hover { color: rgba(255, 255, 255, 0.8); text-decoration: underline; }

        /* === å³ä¸Šè§’æ°´å° (ä»…å…è´¹ç‰ˆæ˜¾ç¤º) === */
        #watermark {
            position: absolute;
            top: 20px; right: 25px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.3);
            letter-spacing: 2px;
            z-index: 5;
            cursor: pointer;
            font-weight: bold;
            pointer-events: auto;
            transition: all 0.3s;
            display: none; 
        }
        #watermark:hover {
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* === ç»“æŸåçš„å½©è›‹å¹¿å‘Š (ä»…å…è´¹ç‰ˆæ˜¾ç¤º) === */
        #end-ad {
            position: absolute;
            bottom: 40px; right: 30px; 
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            padding: 10px 20px;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px;
            letter-spacing: 1px;
            cursor: pointer;
            z-index: 8;
            opacity: 0; 
            transform: translateY(20px);
            transition: all 0.8s cubic-bezier(0.22, 1, 0.36, 1);
            display: none; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        #end-ad:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(20px) scale(1.05);
            box-shadow: 0 5px 25px rgba(100, 200, 255, 0.3);
        }
        
        @media (max-width: 768px) {
            #end-ad {
                bottom: 30px; right: 50%;
                transform: translateX(50%) translateY(20px);
                width: max-content;
            }
            #end-ad:hover {
                transform: translateX(50%) translateY(20px) scale(1.05);
            }
            #end-ad.visible {
                opacity: 1;
                transform: translateX(50%) translateY(0) !important;
            }
        }
        
        @media (min-width: 769px) {
            #end-ad.visible {
                opacity: 1;
                transform: translateY(0) !important;
            }
        }

    </style>
</head>
<body>

<div id="world">
    <div id="start-container">
        <div id="overlay" onmousemove="moveGlow(event)" ontouchmove="moveGlow(event)">å¼€å¯ 2026 ğŸ†</div>
        <div id="start-subtext" onclick="goBuy()">Powered by ä¸ƒå¶æ€€ç‘¾ | å®šåˆ¶ä¸“å±æ–‡å­—</div>
    </div>

    <div id="watermark" onclick="goBuy()">ä¸ƒå¶æ€€ç‘¾</div>

    <div id="end-ad" onclick="goBuy()">
        æˆ‘ä¹Ÿè¦é€ TA ä¸€å¥ç‹¬ç‰¹çš„ç¥ç¦ <span style="margin-left:8px; opacity:0.7">ğŸ‘‰ ç‚¹å‡»è·å–ä¸“å±é“¾æ¥</span>
    </div>

    <canvas id="canvas"></canvas>
</div>

<script>
    // === V36.0 æ— å€’è®¡æ—¶å•å¥ç‰ˆ ===
    
    const BUY_LINK = "../#buy"; 
    const API_DECODE_URL = "https://vimalin.xyz:8443/api/decode"; 

    // === æ ¸å¿ƒé…ç½® ===
    let config = {
        // ã€ä¿®æ”¹ç‚¹ã€‘é»˜è®¤åªæœ‰ä¸€å¥è¯ï¼Œæ²¡æœ‰å€’è®¡æ—¶
        textList: ["2026 æ–°å¹´å¿«ä¹"],
        
        // --- è§†è§‰ä¸ç‰©ç†é…ç½® ---
        fontSizeMultiplier: 0.12, 
        resolutionGap: 4,         // é—´è·4 (ç»†è…»)
        particleSize: 1.8,        // ç²’å­1.8 (å°å·§)
        secondaryChance: 0.3,     // 30%æ¦‚ç‡äºŒæ¬¡çˆ†ç‚¸
        gravity: 0.05,            
        friction: 0.96,           
        trailAlpha: 0.12,         // æ‹–å°¾é€æ˜åº¦
        
        // --- å‘å°„é€»è¾‘ ---
        normalFireworkChance: 0.1, // å°çƒŸèŠ±å¸¸æ”¾
        bigFireworkChance: 0.05    // å¤§çƒŸèŠ±å—é”æ§åˆ¶
    };

    // å…¨å±€çŠ¶æ€
    let isPaidUser = false; 
    let hasShownAd = false; 
    let isRunning = false;
    let currentTextIndex = 0;
    
    // çƒŸèŠ±ç›¸å…³å…¨å±€å˜é‡
    let fireworks = [];
    let particles = [];
    let textGrid = {}; 
    let totalTextPixels = 0;
    let filledPixels = 0;
    let isTextFull = false;
    let bigFireworkActive = false;
    let bigFireworkCooldown = 0;
    let isSwitchingText = false; 

    function goBuy() { window.location.href = BUY_LINK; }

    function moveGlow(e) {
        const btn = e.currentTarget;
        const rect = btn.getBoundingClientRect();
        let clientX = e.clientX;
        let clientY = e.clientY;
        if(e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        }
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        btn.style.setProperty('--x', x + 'px');
        btn.style.setProperty('--y', y + 'px');
    }

    // === 1. è·å–è§£å¯†æ•°æ® ===
    async function fetchDecryptedPayload() {
        const params = new URLSearchParams(window.location.search);
        const code = params.get('code');
        
        if (code) {
            try {
                const response = await fetch(API_DECODE_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code: code })
                });
                const result = await response.json();
                
                if (result.success && result.data) {
                    const payload = result.data;
                    console.log("Verified Gift:", payload);
                    
                    if (payload.wish) { 
                        isPaidUser = true; 
                        
                        // ã€ä¿®æ”¹ç‚¹ã€‘ä»˜è´¹ç‰ˆä¹Ÿä¸å†åŠ å€’è®¡æ—¶ï¼Œç›´æ¥æ”¾å†…å®¹
                        let newTextList = []; 
                        
                        if(payload.wish) { 
                            const lines = payload.wish.split('\n').filter(line => line.trim() !== ''); 
                            newTextList.push(...lines); 
                        } 
                        
                        // å¦‚æœå› ä¸ºæŸç§åŸå› åˆ—è¡¨ç©ºäº†ï¼Œç»™ä¸ªä¿åº•
                        if(newTextList.length === 0) newTextList.push("2026 æ–°å¹´å¿«ä¹");

                        config.textList = newTextList; 
                        initUI(); 
                    }
                }
            } catch (e) { console.error("API Error:", e); }
        }
    }
    fetchDecryptedPayload();

    function initUI() {
        if (isPaidUser) {
            const wm = document.getElementById('watermark');
            if(wm) wm.style.display = 'none';
        } else {
            const wm = document.getElementById('watermark');
            if(wm) wm.style.display = 'block';
            const endAd = document.getElementById('end-ad');
            if(endAd) endAd.style.display = 'block';
        }
    }
    initUI();

    const world = document.getElementById('world');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let isMobile = false;
    let dpr = 1;

    // === 2. åˆå§‹åŒ–ç”»å¸ƒ ===
    function init() {
        const screenW = window.innerWidth;
        const screenH = window.innerHeight;

        // å¼ºåˆ¶æ¨ªå±é€»è¾‘
        if (screenW < screenH) {
            isMobile = true;
            world.style.width = screenH + 'px';
            world.style.height = screenW + 'px';
            world.style.transform = 'rotate(90deg)';
            world.style.transformOrigin = 'top left';
            world.style.left = '100%'; 
            world.style.top = '0';
            width = screenH;
            height = screenW;
        } else {
            isMobile = screenW < 1024;
            world.style.width = '100vw';
            world.style.height = '100vh';
            world.style.transform = 'none';
            world.style.left = '0';
            width = screenW;
            height = screenH;
        }

        dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        ctx.scale(dpr, dpr);
        
        // åˆå§‹åŒ–å½“å‰æ–‡å­—
        initTextGrid(config.textList[currentTextIndex]);
    }

    window.addEventListener('resize', () => {
        if(!isRunning) init();
        else {
            // window.location.reload(); 
        }
    });

    // === 3. æ ¸å¿ƒï¼šå»ºç«‹æ–‡å­—ç½‘æ ¼ ===
    function initTextGrid(text) {
        textGrid = {};
        totalTextPixels = 0;
        filledPixels = 0;
        isTextFull = false;
        
        particles.forEach(p => { if(p.isStuck) { p.isStuck = false; p.dead = true; p.alpha = 0; } });
        particles = particles.filter(p => !p.dead);

        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = width;
        tempCanvas.height = height;

        let fontSize = Math.min(width, height) * 0.12;
        if (isMobile) fontSize *= 1.3;
        tempCtx.font = `bold ${fontSize}px "Microsoft YaHei", sans-serif`;
        tempCtx.fillStyle = 'white';
        tempCtx.textAlign = 'center';
        tempCtx.textBaseline = 'middle';

        // --- è‡ªåŠ¨æ¢è¡Œé€»è¾‘å¼€å§‹ ---
        const maxWidth = width * 0.8;
        const lineHeight = fontSize * 1.2;
        const words = text.split('');
        let lines = [];
        let currentLine = words[0];

        for (let i = 1; i < words.length; i++) {
            const char = words[i];
            const testWidth = tempCtx.measureText(currentLine + char).width;
            if (testWidth < maxWidth) {
                currentLine += char;
            } else {
                lines.push(currentLine);
                currentLine = char;
            }
        }
        lines.push(currentLine);

        const totalHeight = lines.length * lineHeight;
        const startY = (height - totalHeight) / 2 + (lineHeight / 2);

        lines.forEach((line, i) => {
            tempCtx.fillText(line, width / 2, startY + i * lineHeight);
        });
        // --- è‡ªåŠ¨æ¢è¡Œé€»è¾‘ç»“æŸ ---

        const imageData = tempCtx.getImageData(0, 0, width, height);
        const data = imageData.data;
        const gap = config.resolutionGap;

        for (let y = height - 1; y >= 0; y -= gap) {
            const alignedY = Math.floor(y / gap) * gap;
            if (!textGrid[alignedY]) textGrid[alignedY] = {};
            for (let x = 0; x < width; x += gap) {
                const alignedX = Math.floor(x / gap) * gap;
                if (data[(y * width + x) * 4 + 3] > 128) {
                    textGrid[alignedY][alignedX] = { filled: false, color: null };
                    totalTextPixels++;
                }
            }
        }
    }

    // === 4. çƒŸèŠ±ç³»ç»Ÿ ===
    class Firework {
        constructor(type) {
            this.type = type; 
            this.x = Math.random() * width;
            this.y = height;
            
            if (this.type === 'big') {
                this.targetY = height * 0.15 + Math.random() * (height * 0.25); 
                this.speed = 11 + Math.random() * 3;
            } else {
                this.targetY = height * 0.2 + Math.random() * (height * 0.5);
                this.speed = 8 + Math.random() * 4;
            }

            this.angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.15;
            this.vx = Math.cos(this.angle) * this.speed;
            this.vy = Math.sin(this.angle) * this.speed;
            this.hue = Math.floor(Math.random() * 360);
            this.dead = false;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += config.gravity;

            if (this.vy >= 0 || this.y <= this.targetY) {
                this.dead = true;
                createExplosion(this.x, this.y, this.hue, this.type, 1);
            }
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.type === 'big' ? 2.5 : 1.5, 0, Math.PI * 2);
            ctx.fillStyle = `hsl(${this.hue}, 80%, 60%)`;
            ctx.fill();
        }
    }

    class Particle {
        constructor(x, y, vx, vy, hue, type, generation) {
            this.x = x; this.y = y;
            this.vx = vx; this.vy = vy;
            this.type = type;
            this.generation = generation;

            const colorVar = (Math.random() - 0.5) * 50;
            this.color = `hsl(${hue + colorVar}, 90%, 65%)`;
            this.alpha = 1;
            this.decay = (type === 'big') ? (Math.random() * 0.006 + 0.003) : (Math.random() * 0.015 + 0.005);
            
            this.isStuck = false;
            this.hasSecondary = (type === 'big' && generation === 1) && (Math.random() < config.secondaryChance);
        }

        update() {
            if (this.isStuck) return;

            this.vx *= config.friction;
            this.vy *= config.friction;
            this.vy += config.gravity;
            this.x += this.vx;
            this.y += this.vy;
            this.alpha -= this.decay;

            if (this.hasSecondary && this.alpha < 0.5 && this.alpha > 0.2) {
                this.hasSecondary = false; 
                const subHue = parseInt(this.color.match(/\d+/)[0]) + 30; 
                createExplosion(this.x, this.y, subHue, 'big', 2);
                this.alpha = 0; 
                return;
            }

            // ç››æ°´å¡«å……
            if (!isTextFull && this.vy > 0) {
                const gap = config.resolutionGap;
                const gridX = Math.floor(this.x / gap) * gap;
                const gridY = Math.floor(this.y / gap) * gap;

                if (textGrid[gridY] && textGrid[gridY][gridX] && !textGrid[gridY][gridX].filled) {
                    const nextGridY = gridY + gap;
                    let canFill = false;
                    
                    if (!textGrid[nextGridY] || !textGrid[nextGridY][gridX]) {
                        canFill = true; 
                    } else if (textGrid[nextGridY][gridX].filled) {
                        canFill = true; 
                    }

                    if (canFill) {
                        this.isStuck = true;
                        this.x = gridX;
                        this.y = gridY;
                        this.alpha = 1; 
                        this.hasSecondary = false; 
                        
                        textGrid[gridY][gridX].filled = true;
                        textGrid[gridY][gridX].color = this.color;
                        filledPixels++;
                        
                        if (filledPixels >= totalTextPixels) isTextFull = true;
                    }
                }
            }
        }

        draw() {
            ctx.save();
            const finalColor = this.isStuck && textGrid[this.y] ? textGrid[this.y][this.x].color : this.color;
            ctx.globalAlpha = this.alpha;
            ctx.beginPath();
            
            let size = config.particleSize; 
            if (this.isStuck) size = config.particleSize * 0.9; 
            
            ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
            ctx.fillStyle = finalColor;
            ctx.fill();
            ctx.restore();
        }
    }

    function createExplosion(x, y, hue, type, generation) {
        const sizeScale = 0.5 + Math.random() * 1.5; 
        
        let particleCount;
        if (type === 'big') {
            particleCount = (generation === 1) ? 300 * sizeScale : 20; 
        } else {
            particleCount = 60; 
        }

        const styles = ['sphere', 'ring', 'burst', 'double'];
        let style = 'burst';
        if (type === 'big' && generation === 1) {
            style = styles[Math.floor(Math.random() * styles.length)];
        }

        for (let i = 0; i < particleCount; i++) {
            let vx, vy, speed, angle;
            switch(style) {
                case 'ring':
                    angle = (Math.PI * 2 / particleCount) * i;
                    speed = 6 * sizeScale;
                    vx = Math.cos(angle) * speed;
                    vy = Math.sin(angle) * speed;
                    break;
                case 'double':
                    angle = Math.random() * Math.PI * 2;
                    speed = (i % 2 === 0 ? 8 : 4) * sizeScale;
                    vx = Math.cos(angle) * speed;
                    vy = Math.sin(angle) * speed;
                    break;
                case 'sphere':
                    angle = Math.random() * Math.PI * 2;
                    speed = Math.random() * 9 * sizeScale;
                    vx = Math.cos(angle) * speed;
                    vy = Math.sin(angle) * speed;
                    break;
                case 'burst': default:
                    angle = Math.random() * Math.PI * 2;
                    let baseSpeed = (type === 'big') ? 8 : 4;
                    speed = (Math.random() * baseSpeed + 2) * sizeScale;
                    vx = Math.cos(angle) * speed;
                    vy = Math.sin(angle) * speed;
                    break;
            }
            particles.push(new Particle(x, y, vx, vy, hue, type, generation));
        }

        if (type === 'big' && generation === 1) {
            bigFireworkCooldown = Date.now() + 2500;
        }
    }

    // === 5. åŠ¨ç”»å¾ªç¯ ===
    function animate() {
        if(!isRunning) return;
        requestAnimationFrame(animate);

        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = `rgba(2, 2, 5, ${config.trailAlpha})`;
        ctx.fillRect(0, 0, width, height);
        ctx.globalCompositeOperation = 'lighter';

        // å‘å°„
        if (Math.random() < config.normalFireworkChance) fireworks.push(new Firework('normal'));
        if (bigFireworkActive) {
            if (Date.now() > bigFireworkCooldown) {
                const bigParticlesLeft = particles.filter(p => p.type === 'big' && !p.isStuck).length;
                if (bigParticlesLeft < 50) bigFireworkActive = false;
            }
        } else if (Math.random() < config.bigFireworkChance) {
            fireworks.push(new Firework('big'));
            bigFireworkActive = true;
        }

        // æ›´æ–°å®ä½“
        for (let i = fireworks.length - 1; i >= 0; i--) {
            fireworks[i].update();
            fireworks[i].draw();
            if (fireworks[i].dead) fireworks.splice(i, 1);
        }

        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            particles[i].draw();
            if (!particles[i].isStuck && particles[i].alpha <= 0.01) {
                particles.splice(i, 1);
            }
        }

        // åˆ‡æ¢æ–‡å­—é€»è¾‘
        if (isTextFull && !isSwitchingText) {
            isSwitchingText = true;
            // é»˜è®¤åœç•™ 3ç§’
            setTimeout(() => {
                currentTextIndex++;
                if (currentTextIndex >= config.textList.length) {
                    currentTextIndex = config.textList.length - 1; 
                    
                    // æ˜¾ç¤ºåº•éƒ¨å¹¿å‘Š
                    if (!hasShownAd && !isPaidUser) {
                        const ad = document.getElementById('end-ad');
                        if(ad) {
                            ad.style.display = 'block'; 
                            setTimeout(() => ad.classList.add('visible'), 100); 
                        }
                        hasShownAd = true;
                    }
                } else {
                    initTextGrid(config.textList[currentTextIndex]);
                    isSwitchingText = false;
                }
            }, 3000);
        }
    }

    // === 6. äº¤äº’ ===
    init(); // é¢„åŠ è½½

    const overlay = document.getElementById('overlay');
    const startContainer = document.getElementById('start-container');

    overlay.addEventListener('click', () => {
        startContainer.style.opacity = '0';
        setTimeout(() => startContainer.style.display = 'none', 800);
        
        if (!isRunning) {
            isRunning = true;
            init(); 
            animate();
        }
    });

</script>
</body>
</html>