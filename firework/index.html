<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>çƒŸèŠ±çš„è¯</title>
    
    <link rel="icon" type="image/x-icon" href="../assets/favicon.ico">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205; /* æ·±é‚ƒé»‘èƒŒæ™¯ */
            font-family: 'Microsoft YaHei', sans-serif;
            touch-action: none; 
        }

        #world {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background-color: #020205;
            overflow: hidden;
        }

        canvas { display: block; }
        
        /* === å¯åŠ¨é¡µå®¹å™¨ === */
        #start-container {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
            transition: opacity 0.8s ease;
        }

        /* å¯åŠ¨æŒ‰é’® */
        #overlay {
            display: inline-block;
            color: rgba(255, 255, 255, 0.95);
            font-size: 16px;
            letter-spacing: 4px; /* ç¨å¾®ç¼©å°å­—é—´è·é€‚é…é•¿æ–‡å­— */
            cursor: pointer;
            background: rgba(20, 20, 30, 0.6); 
            backdrop-filter: blur(12px);
            padding: 20px 60px;
            border-radius: 100px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 30px rgba(100, 150, 255, 0.15);
            transition: transform 0.2s, box-shadow 0.3s;
            font-weight: 300;
            text-transform: uppercase;
            white-space: nowrap;
            position: relative;
            overflow: hidden;
        }

        #overlay:hover {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 50px rgba(120, 180, 255, 0.3);
            transform: scale(1.02);
        }
        
        #overlay:active { transform: scale(0.95); }

        /* æŒ‰é’®å…‰æ•ˆ */
        #overlay::before {
            content: ''; position: absolute;
            top: var(--y, 50%); left: var(--x, 50%);
            transform: translate(-50%, -50%);
            width: 150px; height: 150px;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
            opacity: 0; transition: opacity 0.3s;
            pointer-events: none; mix-blend-mode: overlay; 
        }
        #overlay:hover::before { opacity: 1; }

        /* === å¯åŠ¨é¡µä¸‹æ–¹ç‰ˆæƒå°å­— === */
        #start-subtext {
            margin-top: 15px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.4);
            letter-spacing: 1px;
            cursor: pointer;
            text-decoration: none;
            transition: color 0.3s;
        }
        #start-subtext:hover { color: rgba(255, 255, 255, 0.8); text-decoration: underline; }

        /* === å³ä¸Šè§’æ°´å° (ä»…å…è´¹ç‰ˆæ˜¾ç¤º) === */
        #watermark {
            position: absolute;
            top: 20px; right: 25px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.3);
            letter-spacing: 2px;
            z-index: 5;
            cursor: pointer;
            font-weight: bold;
            pointer-events: auto;
            transition: all 0.3s;
            display: none; 
        }
        #watermark:hover {
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* === ç»“æŸåçš„å½©è›‹å¹¿å‘Š (ä»…å…è´¹ç‰ˆæ˜¾ç¤º) === */
        #end-ad {
            position: absolute;
            bottom: 40px; right: 30px; 
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            padding: 10px 20px;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px;
            letter-spacing: 1px;
            cursor: pointer;
            z-index: 8;
            opacity: 0; 
            transform: translateY(20px);
            transition: all 0.8s cubic-bezier(0.22, 1, 0.36, 1);
            display: none; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        #end-ad:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(20px) scale(1.05);
            box-shadow: 0 5px 25px rgba(100, 200, 255, 0.3);
        }
        
        @media (max-width: 768px) {
            #end-ad {
                bottom: 30px; right: 50%;
                transform: translateX(50%) translateY(20px);
                width: max-content;
            }
            #end-ad:hover {
                transform: translateX(50%) translateY(20px) scale(1.05);
            }
            #end-ad.visible {
                opacity: 1;
                transform: translateX(50%) translateY(0) !important;
            }
        }
        
        @media (min-width: 769px) {
            #end-ad.visible {
                opacity: 1;
                transform: translateY(0) !important;
            }
        }

    </style>
</head>
<body>

<div id="world">
    <div id="start-container">
        <div id="overlay" onmousemove="moveGlow(event)" ontouchmove="moveGlow(event)">å¼€å¯ 2026 ğŸ†</div>
        <div id="start-subtext" onclick="goBuy()">Powered by ä¸ƒå¶æ€€ç‘¾ | å®šåˆ¶ä¸“å±æ–‡å­—</div>
    </div>

    <div id="watermark" onclick="goBuy()">ä¸ƒå¶æ€€ç‘¾</div>

    <div id="end-ad" onclick="goBuy()">
        æˆ‘ä¹Ÿè¦é€ TA ä¸€å¥ç‹¬ç‰¹çš„ç¥ç¦ <span style="margin-left:8px; opacity:0.7">ğŸ‘‰ ç‚¹å‡»è·å–ä¸“å±é“¾æ¥</span>
    </div>

    <canvas id="canvas"></canvas>
</div>

<script>
    // === V36.0 æ— å€’è®¡æ—¶å•å¥ç‰ˆ ===
    
    const BUY_LINK = "../#buy"; 
    const API_DECODE_URL = "https://vimalin.xyz:8443/api/decode"; 

    // === æ ¸å¿ƒé…ç½® ===
    let config = {
        // ã€ä¿®æ”¹ç‚¹ã€‘æ··åˆæ¨¡å¼ï¼šç¬¬ä¸€å¥èµ°çƒŸèŠ±å¡«å­—ï¼Œåé¢èµ°æ˜Ÿç©ºç²’å­
        textList: [
            "2026æ–°å¹´å¿«ä¹", // ç´¢å¼•0ï¼šçƒŸèŠ±å¡«å­—
            "3", "2", "1", 
            "2026", 
            "æ–°å¹´å¿«ä¹", 
            "ä¸‡äº‹èƒœæ„", 
            "æ‰€æ„¿çš†å¾—"
        ],
        // ç¬¬ä¸€å¥çš„æ—¶é•¿ç”±å¡«æ»¡é€»è¾‘å†³å®šï¼Œè¿™é‡Œåªé…ç½®åç»­çš„
        textDuration: [null, 1500, 1500, 1500, 3000, 3000, 3000, 4000],
        
        // --- è§†è§‰ä¸ç‰©ç†é…ç½® (çƒŸèŠ±æ¨¡å¼) ---
        fontSizeMultiplier: 0.12, 
        resolutionGap: 5,         // åŠ å¤§é—´è·ï¼Œå‡å°‘åƒç´ ç‚¹ï¼ŒåŠ å¿«å¡«æ»¡é€Ÿåº¦
        particleSize: 1.8,        
        secondaryChance: 0.3,     
        gravity: 0.05,            
        friction: 0.96,           
        trailAlpha: 0.12,         
        
        // --- å‘å°„é€»è¾‘ (çƒŸèŠ±æ¨¡å¼) ---
        normalFireworkChance: 0.2, // æé«˜å‘å°„é¢‘ç‡ï¼ŒåŠ å¿«å¡«æ»¡é€Ÿåº¦
        bigFireworkChance: 0.1     // æé«˜å¤§çƒŸèŠ±é¢‘ç‡
    };

    // å…¨å±€çŠ¶æ€
    let isPaidUser = false; 
    let hasShownAd = false; 
    let isRunning = false;
    let currentTextIndex = 0;
    
    // === æ¨¡å¼ 1ï¼šçƒŸèŠ±ç›¸å…³å˜é‡ ===
    let fireworks = [];
    let particles = [];
    let textGrid = {}; 
    let totalTextPixels = 0;
    let filledPixels = 0;
    let isTextFull = false;
    let bigFireworkActive = false;
    let bigFireworkCooldown = 0;
    let isSwitchingText = false; 

    // === æ¨¡å¼ 2ï¼šæ˜Ÿç©ºç²’å­ç›¸å…³å˜é‡ ===
    const MAX_TEXT_PARTICLES = 15000; 
    let textParticlePool = []; 
    let currentEffect = 'converge';

    function goBuy() { window.location.href = BUY_LINK; }

    function moveGlow(e) {
        // ... (ä¿æŒä¸å˜)
        const btn = e.currentTarget;
        const rect = btn.getBoundingClientRect();
        let clientX = e.clientX;
        let clientY = e.clientY;
        if(e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        }
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        btn.style.setProperty('--x', x + 'px');
        btn.style.setProperty('--y', y + 'px');
    }

    // ... (fetchDecryptedPayload ä¿æŒä¸å˜) ...
    // ä¸ºäº†ç®€åŒ– replaceï¼Œæˆ‘ä¿ç•™ fetchDecryptedPayload çš„å¤§è‡´é€»è¾‘ï¼Œä½†æ³¨æ„è¿™é‡Œéœ€è¦å°å¿ƒä¸Šä¸‹æ–‡
    // ç”±äº replace å·¥å…·é™åˆ¶ï¼Œè¿™é‡Œå‡è®¾ fetchDecryptedPayload æ²¡å˜ï¼Œåªä¿®æ”¹å®ƒä¸Šé¢çš„å˜é‡å’Œå®ƒä¸‹é¢çš„ initUI ä¹‹é—´çš„ä»£ç æ˜¯ä¸å¤Ÿçš„ã€‚
    // æˆ‘å°†æŠŠæ•´ä¸ª script åŒºåŸŸé‡å†™ï¼Œé™¤äº† fetchDecryptedPayload å†…éƒ¨å¤§æ®µé€»è¾‘ï¼Œæˆ–è€…åˆ†å—æ›¿æ¢ã€‚
    // é‰´äºè¿™ä¸ªæ–‡ä»¶ä¸ç®—å¤ªå¤§ï¼Œæˆ‘å°è¯•æ›¿æ¢ä» config å®šä¹‰å¼€å§‹åˆ° animate ç»“æŸçš„å¤§å—åŒºåŸŸã€‚

    // ... (Wait, rewriting the whole script is safer to ensure variable scope is correct) ...


    // === 1. è·å–è§£å¯†æ•°æ® (å¸¦åŠ è½½é”) === 
    async function fetchDecryptedPayload() { 
        const params = new URLSearchParams(window.location.search); 
        const code = params.get('code'); 
        const overlayBtn = document.getElementById('overlay'); 
         
        // åªæœ‰å½“é“¾æ¥å¸¦æœ‰ code æ—¶æ‰è§¦å‘é”å®š 
        if (code) { 
            // --- é”å®šæŒ‰é’®ï¼šé˜²æ­¢æ•°æ®æœªåŠ è½½å®Œå°±ç‚¹å‡» --- 
            overlayBtn.innerText = "çƒŸèŠ±è£…å¡«ä¸­..."; 
            overlayBtn.style.pointerEvents = "none"; // ç¦æ­¢ç‚¹å‡» 
            overlayBtn.style.cursor = "wait";        // é¼ æ ‡å˜æ¼æ–— 
            overlayBtn.style.opacity = "0.8";        // å˜æš— 
            
            try { 
                const response = await fetch(API_DECODE_URL, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ code: code }) 
                }); 
                const result = await response.json(); 
                 
                if (result.success && result.data) { 
                    const payload = result.data; 
                    console.log("Verified Gift:", payload); 
                    
                    if (payload.wish || payload.to || payload.from) { 
                        isPaidUser = true; 
                         
                        // 1. è·å–ç§°å‘¼ 
                        const toUser = payload.to ? payload.to.trim() : ""; 
                        const fromUser = payload.from ? payload.from.trim() : ""; 
   
                        // 2. å®šåˆ¶æŒ‰é’®æ–‡æ¡ˆ (æ•°æ®åŠ è½½æˆåŠŸåæ›´æ–°) 
                        if (toUser && fromUser) { 
                            overlayBtn.innerText = `çœ‹ï¼Œè¿™æ˜¯ ${fromUser} ä¸º ${toUser} ç‡ƒæ”¾çš„çƒŸèŠ±`; 
                            overlayBtn.style.letterSpacing = '1px'; 
                            overlayBtn.style.fontSize = '14px'; 
                            overlayBtn.style.padding = '20px 30px'; 
                        } else if (toUser) { 
                            overlayBtn.innerText = `${toUser}ï¼Œè¿™æ˜¯ä¸ºä½ ç»½æ”¾çš„çƒŸèŠ±`; 
                            overlayBtn.style.letterSpacing = '1px'; 
                            overlayBtn.style.fontSize = '14px'; 
                            overlayBtn.style.padding = '20px 30px'; 
                        } else if (fromUser) { 
                            overlayBtn.innerText = `æ¥è‡ª ${fromUser} çš„ç»šçƒ‚çƒŸç«`; 
                            overlayBtn.style.letterSpacing = '2px'; 
                        } else { 
                            overlayBtn.innerText = "ç‚¹ç‡ƒ 2026 ç»šçƒ‚çƒŸç«"; 
                            overlayBtn.style.letterSpacing = '4px'; 
                        } 
   
                        // 3. æ„å»ºçƒŸèŠ±æ–‡å­—æ’­æ”¾åºåˆ— 
                        let newTextList = []; 
                        if (payload.wish) { 
                            const lines = payload.wish.split('\n').filter(line => line.trim() !== ''); 
                            newTextList.push(...lines); 
                        } 
                        // ä¿åº•é€»è¾‘ 
                        if (newTextList.length === 0) newTextList.push("2026 æ–°å¹´å¿«ä¹"); 
   
                        config.textList = newTextList; 
                    } 
                } else { 
                    // åç«¯è¿”å›æˆåŠŸä½†æ— æ•°æ®ï¼Œæ¢å¤é»˜è®¤ 
                    overlayBtn.innerText = "å¼€å¯ 2026 ğŸ†"; 
                } 
            } catch (e) { 
                console.error("API Error:", e); 
                // ç½‘ç»œé”™è¯¯ï¼Œæ¢å¤é»˜è®¤æ–‡æ¡ˆï¼Œä¿è¯èƒ½ç© 
                overlayBtn.innerText = "å¼€å¯ 2026 ğŸ†"; 
            } finally { 
                // --- è§£é”æŒ‰é’®ï¼šæ— è®ºæˆåŠŸè¿˜æ˜¯å¤±è´¥ï¼Œæœ€åéƒ½å¿…é¡»æ¢å¤å¯ç‚¹å‡»çŠ¶æ€ --- 
                overlayBtn.style.pointerEvents = "auto"; 
                overlayBtn.style.cursor = "pointer"; 
                overlayBtn.style.opacity = "1"; 
                
                initUI(); // åˆ·æ–°æ°´å°çŠ¶æ€ 
            } 
        } 
    }
    fetchDecryptedPayload();

    function initUI() {
        if (isPaidUser) {
            const wm = document.getElementById('watermark');
            if(wm) wm.style.display = 'none';
        } else {
            const wm = document.getElementById('watermark');
            if(wm) wm.style.display = 'block';
            const endAd = document.getElementById('end-ad');
            if(endAd) endAd.style.display = 'block';
        }
    }
    initUI();

    const world = document.getElementById('world');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let isMobile = false;
    let dpr = 1;

    // === è¾…åŠ©ç±»ï¼šæ˜Ÿç©ºç²’å­ ===
    class TextParticle {
        constructor() {
            this.active = false;
            this.x = 0; this.y = 0;
            this.targetX = 0; this.targetY = 0;
            this.vx = 0; this.vy = 0;
            this.angle = 0; this.radius = 0;
            this.color = '';
            this.size = 2.0;
        }
        activate(targetX, targetY, effectType, size = 2.0) {
            this.active = true;
            this.targetX = targetX;
            this.targetY = targetY;
            const mobileScale = isMobile ? 0.6 : 1.0; 
            this.color = `rgba(220, 240, 255, ${0.7 + Math.random() * 0.3})`;
            this.size = 2.0 * mobileScale;
            
            if (this.x === 0 && this.y === 0) {
                 this.x = Math.random() * width;
                 this.y = Math.random() * height;
            }
            switch (effectType) {
                case 'explode': 
                    const dx = this.x - width/2;
                    const dy = this.y - height/2;
                    this.vx = dx * 0.05 + (Math.random() - 0.5) * 10;
                    this.vy = dy * 0.05 + (Math.random() - 0.5) * 10;
                    break;
                case 'spiral': 
                    this.angle = Math.random() * Math.PI * 2;
                    this.radius = 300 + Math.random() * 200; 
                    this.x = targetX + Math.cos(this.angle) * this.radius;
                    this.y = targetY + Math.sin(this.angle) * this.radius;
                    break;
                case 'converge': default: break;
            }
        }
        update(effectType) {
            if (!this.active) return;
            switch (effectType) {
                case 'explode':
                    this.x += this.vx; this.y += this.vy;
                    this.vx *= 0.9; this.vy *= 0.9;
                    this.x += (this.targetX - this.x) * 0.08;
                    this.y += (this.targetY - this.y) * 0.08;
                    break;
                case 'spiral':
                    this.x += (this.targetX - this.x) * 0.08;
                    this.y += (this.targetY - this.y) * 0.08;
                    break;
                case 'converge': default:
                    this.x += (this.targetX - this.x) * 0.08;
                    this.y += (this.targetY - this.y) * 0.08;
                    break;
            }
        }
        draw(ctx) {
            if (!this.active) return;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function getTextCoordinates(text) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = width;
        tempCanvas.height = height;
        
        let fontSize = Math.min(width, height) * 0.15;
        if (isMobile) fontSize *= 1.2;
        tempCtx.font = `bold ${fontSize}px "Microsoft YaHei", sans-serif`;
        tempCtx.fillStyle = 'white';
        tempCtx.textAlign = 'center';
        tempCtx.textBaseline = 'middle';

        const maxWidth = width * 0.85;
        const lineHeight = fontSize * 1.2;
        const words = text.split('');
        let lines = [];
        let currentLine = words[0];

        for (let i = 1; i < words.length; i++) {
            const char = words[i];
            const testWidth = tempCtx.measureText(currentLine + char).width;
            if (testWidth < maxWidth) {
                currentLine += char;
            } else {
                lines.push(currentLine);
                currentLine = char;
            }
        }
        lines.push(currentLine);

        const totalHeight = lines.length * lineHeight;
        const startY = (height - totalHeight) / 2 + (lineHeight / 2);

        lines.forEach((line, i) => {
            tempCtx.fillText(line, width / 2, startY + i * lineHeight);
        });
        
        const imageData = tempCtx.getImageData(0, 0, width, height);
        const data = imageData.data;
        const coords = [];
        const gap = isMobile ? 3 : 4;
        
        for (let y = 0; y < height; y += gap) {
            for (let x = 0; x < width; x += gap) {
                if (data[(y * width + x) * 4 + 3] > 180) {
                    coords.push({ x: x, y: y });
                }
            }
        }
        return coords;
    }

    // === 2. åˆå§‹åŒ–ç”»å¸ƒ ===
    function init() {
        const screenW = window.innerWidth;
        const screenH = window.innerHeight;

        // å¼ºåˆ¶æ¨ªå±é€»è¾‘
        if (screenW < screenH) {
            isMobile = true;
            world.style.width = screenH + 'px';
            world.style.height = screenW + 'px';
            world.style.transform = 'rotate(90deg)';
            world.style.transformOrigin = 'top left';
            world.style.left = '100%'; 
            world.style.top = '0';
            width = screenH;
            height = screenW;
        } else {
            isMobile = screenW < 1024;
            world.style.width = '100vw';
            world.style.height = '100vh';
            world.style.transform = 'none';
            world.style.left = '0';
            width = screenW;
            height = screenH;
        }

        dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        ctx.scale(dpr, dpr);
        
        // åˆå§‹åŒ–å½“å‰æ–‡å­— (å¦‚æœæ˜¯ç¬¬ä¸€å¥ï¼Œåˆå§‹åŒ– Grid)
        if (currentTextIndex === 0) {
            initTextGrid(config.textList[0]);
        }

        // åˆå§‹åŒ–æ˜Ÿç©ºç²’å­æ± 
        if (textParticlePool.length === 0) {
            for (let i = 0; i < MAX_TEXT_PARTICLES; i++) {
                textParticlePool.push(new TextParticle());
            }
        }
    }

    window.addEventListener('resize', () => {
        if(!isRunning) init();
        else {
            // window.location.reload(); 
        }
    });

    // === 3. æ ¸å¿ƒï¼šå»ºç«‹æ–‡å­—ç½‘æ ¼ ===
    function initTextGrid(text) {
        textGrid = {};
        totalTextPixels = 0;
        filledPixels = 0;
        isTextFull = false;
        
        particles.forEach(p => { if(p.isStuck) { p.isStuck = false; p.dead = true; p.alpha = 0; } });
        particles = particles.filter(p => !p.dead);

        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = width;
        tempCanvas.height = height;

        let fontSize = Math.min(width, height) * 0.12;
        if (isMobile) fontSize *= 1.3;
        tempCtx.font = `bold ${fontSize}px "Microsoft YaHei", sans-serif`;
        tempCtx.fillStyle = 'white';
        tempCtx.textAlign = 'center';
        tempCtx.textBaseline = 'middle';

        // --- è‡ªåŠ¨æ¢è¡Œé€»è¾‘å¼€å§‹ ---
        const maxWidth = width * 0.8;
        const lineHeight = fontSize * 1.2;
        const words = text.split('');
        let lines = [];
        let currentLine = words[0];

        for (let i = 1; i < words.length; i++) {
            const char = words[i];
            const testWidth = tempCtx.measureText(currentLine + char).width;
            if (testWidth < maxWidth) {
                currentLine += char;
            } else {
                lines.push(currentLine);
                currentLine = char;
            }
        }
        lines.push(currentLine);

        const totalHeight = lines.length * lineHeight;
        const startY = (height - totalHeight) / 2 + (lineHeight / 2);

        lines.forEach((line, i) => {
            tempCtx.fillText(line, width / 2, startY + i * lineHeight);
        });
        // --- è‡ªåŠ¨æ¢è¡Œé€»è¾‘ç»“æŸ ---

        const imageData = tempCtx.getImageData(0, 0, width, height);
        const data = imageData.data;
        const gap = config.resolutionGap;

        for (let y = height - 1; y >= 0; y -= gap) {
            const alignedY = Math.floor(y / gap) * gap;
            if (!textGrid[alignedY]) textGrid[alignedY] = {};
            for (let x = 0; x < width; x += gap) {
                const alignedX = Math.floor(x / gap) * gap;
                if (data[(y * width + x) * 4 + 3] > 128) {
                    textGrid[alignedY][alignedX] = { filled: false, color: null };
                    totalTextPixels++;
                }
            }
        }
    }

    // === 4. çƒŸèŠ±ç³»ç»Ÿ ===
    class Firework {
        constructor(type) {
            this.type = type; 
            this.x = Math.random() * width;
            this.y = height;
            
            if (this.type === 'big') {
                this.targetY = height * 0.15 + Math.random() * (height * 0.25); 
                this.speed = 11 + Math.random() * 3;
            } else {
                this.targetY = height * 0.2 + Math.random() * (height * 0.5);
                this.speed = 8 + Math.random() * 4;
            }

            this.angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.15;
            this.vx = Math.cos(this.angle) * this.speed;
            this.vy = Math.sin(this.angle) * this.speed;
            this.hue = Math.floor(Math.random() * 360);
            this.dead = false;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += config.gravity;

            if (this.vy >= 0 || this.y <= this.targetY) {
                this.dead = true;
                createExplosion(this.x, this.y, this.hue, this.type, 1);
            }
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.type === 'big' ? 2.5 : 1.5, 0, Math.PI * 2);
            ctx.fillStyle = `hsl(${this.hue}, 80%, 60%)`;
            ctx.fill();
        }
    }

    class Particle {
        constructor(x, y, vx, vy, hue, type, generation) {
            this.x = x; this.y = y;
            this.vx = vx; this.vy = vy;
            this.type = type;
            this.generation = generation;

            const colorVar = (Math.random() - 0.5) * 50;
            this.color = `hsl(${hue + colorVar}, 90%, 65%)`;
            this.alpha = 1;
            this.decay = (type === 'big') ? (Math.random() * 0.006 + 0.003) : (Math.random() * 0.015 + 0.005);
            
            this.isStuck = false;
            this.hasSecondary = (type === 'big' && generation === 1) && (Math.random() < config.secondaryChance);
        }

        update() {
            if (this.isStuck) return;

            this.vx *= config.friction;
            this.vy *= config.friction;
            this.vy += config.gravity;
            this.x += this.vx;
            this.y += this.vy;
            this.alpha -= this.decay;

            if (this.hasSecondary && this.alpha < 0.5 && this.alpha > 0.2) {
                this.hasSecondary = false; 
                const subHue = parseInt(this.color.match(/\d+/)[0]) + 30; 
                createExplosion(this.x, this.y, subHue, 'big', 2);
                this.alpha = 0; 
                return;
            }

            // ç››æ°´å¡«å…… (ä»…åœ¨ç¬¬ä¸€å¥æ¨¡å¼ä¸‹ç”Ÿæ•ˆ)
            if (currentTextIndex === 0 && !isTextFull && this.vy > 0) {
                const gap = config.resolutionGap;
                const gridX = Math.floor(this.x / gap) * gap;
                const gridY = Math.floor(this.y / gap) * gap;

                if (textGrid[gridY] && textGrid[gridY][gridX] && !textGrid[gridY][gridX].filled) {
                    const nextGridY = gridY + gap;
                    let canFill = false;
                    
                    if (!textGrid[nextGridY] || !textGrid[nextGridY][gridX]) {
                        canFill = true; 
                    } else if (textGrid[nextGridY][gridX].filled) {
                        canFill = true; 
                    }

                    if (canFill) {
                        this.isStuck = true;
                        this.x = gridX;
                        this.y = gridY;
                        this.alpha = 1; 
                        this.hasSecondary = false; 
                        
                        textGrid[gridY][gridX].filled = true;
                        textGrid[gridY][gridX].color = this.color;
                        filledPixels++;
                        
                        if (filledPixels >= totalTextPixels) isTextFull = true;
                    }
                }
            }
        }

        draw() {
            ctx.save();
            const finalColor = this.isStuck && textGrid[this.y] ? textGrid[this.y][this.x].color : this.color;
            ctx.globalAlpha = this.alpha;
            ctx.beginPath();
            
            let size = config.particleSize; 
            if (this.isStuck) size = config.particleSize * 0.9; 
            
            ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
            ctx.fillStyle = finalColor;
            ctx.fill();
            ctx.restore();
        }
    }

    function createExplosion(x, y, hue, type, generation) {
        const sizeScale = 0.5 + Math.random() * 1.5; 
        
        let particleCount;
        if (type === 'big') {
            particleCount = (generation === 1) ? 300 * sizeScale : 20; 
        } else {
            particleCount = 60; 
        }

        const styles = ['sphere', 'ring', 'burst', 'double'];
        let style = 'burst';
        if (type === 'big' && generation === 1) {
            style = styles[Math.floor(Math.random() * styles.length)];
        }

        for (let i = 0; i < particleCount; i++) {
            let vx, vy, speed, angle;
            switch(style) {
                case 'ring':
                    angle = (Math.PI * 2 / particleCount) * i;
                    speed = 6 * sizeScale;
                    vx = Math.cos(angle) * speed;
                    vy = Math.sin(angle) * speed;
                    break;
                case 'double':
                    angle = Math.random() * Math.PI * 2;
                    speed = (i % 2 === 0 ? 8 : 4) * sizeScale;
                    vx = Math.cos(angle) * speed;
                    vy = Math.sin(angle) * speed;
                    break;
                case 'sphere':
                    angle = Math.random() * Math.PI * 2;
                    speed = Math.random() * 9 * sizeScale;
                    vx = Math.cos(angle) * speed;
                    vy = Math.sin(angle) * speed;
                    break;
                case 'burst': default:
                    angle = Math.random() * Math.PI * 2;
                    let baseSpeed = (type === 'big') ? 8 : 4;
                    speed = (Math.random() * baseSpeed + 2) * sizeScale;
                    vx = Math.cos(angle) * speed;
                    vy = Math.sin(angle) * speed;
                    break;
            }
            particles.push(new Particle(x, y, vx, vy, hue, type, generation));
        }

        if (type === 'big' && generation === 1) {
            bigFireworkCooldown = Date.now() + 2500;
        }
    }

    function activateStarText(index) {
        const text = config.textList[index];
        const coords = getTextCoordinates(text);
        
        const effects = ['converge', 'spiral', 'explode'];
        
        if (index < 4 && /^\d+$/.test(text)) {
             currentEffect = Math.random() > 0.5 ? 'explode' : 'converge';
        } else {
            currentEffect = effects[Math.floor(Math.random() * effects.length)];
        }

        textParticlePool.forEach(p => p.active = false);
        for (let i = 0; i < coords.length && i < textParticlePool.length; i++) {
            textParticlePool[i].activate(coords[i].x, coords[i].y, currentEffect);
        }
    }

    function scheduleNextStarSwitch() {
        if (currentTextIndex === 0) return; 
        
        let delay = config.textDuration[currentTextIndex] || 3000;
        
        setTimeout(() => {
            currentTextIndex++;
            
            // === å¾ªç¯é€»è¾‘ ===
            if (currentTextIndex >= config.textList.length) {
                 currentTextIndex = 4; // å›åˆ° "2026" å¼€å§‹å¾ªç¯ (è·³è¿‡å€’è®¡æ—¶)
                 if (currentTextIndex >= config.textList.length) currentTextIndex = 1;

                 // æ˜¾ç¤ºå¹¿å‘Š
                 if (!hasShownAd && !isPaidUser) { 
                    const ad = document.getElementById('end-ad'); 
                    if(ad) { 
                        ad.style.display = 'block'; 
                        setTimeout(() => ad.classList.add('visible'), 100); 
                    } 
                    hasShownAd = true; 
                } 
            }
            
            activateStarText(currentTextIndex);
            scheduleNextStarSwitch();
            
        }, delay);
    }

    // === 5. åŠ¨ç”»å¾ªç¯ ===
    function animate() {
        if(!isRunning) return;
        requestAnimationFrame(animate);

        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = `rgba(2, 2, 5, ${config.trailAlpha})`;
        ctx.fillRect(0, 0, width, height);
        ctx.globalCompositeOperation = 'lighter';

        // === å…¨å±€èƒŒæ™¯çƒŸèŠ± ===
        // ä»…åœ¨â€œå¡«å­—é˜¶æ®µ(0)â€æˆ–â€œå€’è®¡æ—¶ç»“æŸåçš„ç¥ç¦è¯­é˜¶æ®µ(>=4)â€ç‡ƒæ”¾çƒŸèŠ±
        // å€’è®¡æ—¶é˜¶æ®µ(1,2,3)æš‚åœèƒŒæ™¯çƒŸèŠ±ï¼Œåªæ˜¾ç¤ºæ•°å­—
        if (currentTextIndex === 0 || currentTextIndex >= 4) {
            // å‘å°„
            if (Math.random() < config.normalFireworkChance) fireworks.push(new Firework('normal'));
            if (bigFireworkActive) {
                if (Date.now() > bigFireworkCooldown) {
                    const bigParticlesLeft = particles.filter(p => p.type === 'big' && !p.isStuck).length;
                    if (bigParticlesLeft < 50) bigFireworkActive = false;
                }
            } else if (Math.random() < config.bigFireworkChance) {
                fireworks.push(new Firework('big'));
                bigFireworkActive = true;
            }
        }

        // æ›´æ–°çƒŸèŠ±ç«ç®­
        for (let i = fireworks.length - 1; i >= 0; i--) {
            fireworks[i].update();
            fireworks[i].draw();
            if (fireworks[i].dead) fireworks.splice(i, 1);
        }

        // æ›´æ–°çƒŸèŠ±ç²’å­
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            particles[i].draw();
            // å¦‚æœæ²¡ç²˜ä½ä¸”é€æ˜åº¦è¿‡ä½ï¼Œç§»é™¤
            if (!particles[i].isStuck && particles[i].alpha <= 0.01) {
                particles.splice(i, 1);
            }
        }

        // === æ¨¡å¼ 1: çƒŸèŠ±å¡«å­—é€»è¾‘ (ä»… Index 0) ===
        if (currentTextIndex === 0) {
            // åˆ‡æ¢æ£€æµ‹
            if (isTextFull && !isSwitchingText) { 
                isSwitchingText = true; 
                
                // å¡«æ»¡ååœç•™ 4ç§’ï¼Œç„¶ååˆ‡å…¥å€’è®¡æ—¶
                setTimeout(() => { 
                    currentTextIndex++; 
                    
                    // ã€å…³é”®ã€‘åªæ¸…ç†ç²˜åœ¨æ–‡å­—ä¸Šçš„ç²’å­ï¼Œä¿ç•™ç©ºä¸­é£èˆçš„çƒŸèŠ±èƒŒæ™¯
                    particles = particles.filter(p => !p.isStuck);
                    
                    // å¯åŠ¨æ˜Ÿç©ºç²’å­
                    activateStarText(currentTextIndex);
                    isSwitchingText = false; 
                    
                    // å¼€å§‹æ˜Ÿç©ºå¾ªç¯
                    scheduleNextStarSwitch();

                }, 4000); 
            }
        } 
        // === æ¨¡å¼ 2: æ˜Ÿç©ºç²’å­ (åç»­æ–‡å­—) ===
        else {
            textParticlePool.forEach(p => {
                p.update(currentEffect);
                p.draw(ctx);
            });
        }
    }

    // === 6. äº¤äº’ ===
    init(); // é¢„åŠ è½½

    const overlay = document.getElementById('overlay');
    const startContainer = document.getElementById('start-container');

    overlay.addEventListener('click', () => {
        startContainer.style.opacity = '0';
        setTimeout(() => startContainer.style.display = 'none', 800);
        
        if (!isRunning) {
            isRunning = true;
            init(); 
            animate();
        }
    });

</script>
</body>
</html>